<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>LeetCode题目 | Hexo</title><meta name="description" content="LeetCode题目"><meta name="keywords" content=""><meta name="author" content="Ash's Blogs"><meta name="copyright" content="Ash's Blogs"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="LeetCode题目"><meta name="twitter:description" content="LeetCode题目"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><meta property="og:type" content="article"><meta property="og:title" content="LeetCode题目"><meta property="og:url" content="http://yoursite.com/2019/12/01/leecode%E9%A2%98%E7%9B%AE/"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="LeetCode题目"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2019/12/01/leecode%E9%A2%98%E7%9B%AE/"><link rel="prev" title="日常" href="http://yoursite.com/2019/12/04/%E6%97%A5%E5%B8%B8/"><link rel="next" title="word2vec练习" href="http://yoursite.com/2019/11/24/word2vec%E7%BB%83%E4%B9%A0/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'false',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'false',
  Snackbar: undefined
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Hexo</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">8</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">8</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#单词拆分"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">139. 单词拆分</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目描述"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">1.题目描述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#代码实现"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">代码实现</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#动态规划"><span class="toc_mobile_items-number">1.2.1.</span> <span class="toc_mobile_items-text">动态规划</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#dfs剪枝"><span class="toc_mobile_items-number">1.2.2.</span> <span class="toc_mobile_items-text">dfs+剪枝</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#最长回文子串"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">5. 最长回文子串</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#解题思路"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">解题思路</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#代码实现-1"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">代码实现</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#丑数-i"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">263. 丑数 I</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目描述-1"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">题目描述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#打家劫舍i"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">1.打家劫舍I</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#题目描述-2"><span class="toc_mobile_items-number">3.2.1.</span> <span class="toc_mobile_items-text">1.1题目描述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#代码实现-2"><span class="toc_mobile_items-number">3.2.2.</span> <span class="toc_mobile_items-text">2.3代码实现</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#穿过迷宫的最少移动次数"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">5208. 穿过迷宫的最少移动次数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目描述-3"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">题目描述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#代码实现-3"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">代码实现</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#leetcode-120.-三角形最小路径和"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">Leetcode 120. 三角形最小路径和</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目描述-4"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">题目描述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#代码实现-4"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">代码实现</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#不带空间优化"><span class="toc_mobile_items-number">5.2.1.</span> <span class="toc_mobile_items-text">不带空间优化</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#空间优化"><span class="toc_mobile_items-number">5.2.2.</span> <span class="toc_mobile_items-text">空间优化</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#leetcode-435.-无重叠区间"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">Leetcode 435. 无重叠区间</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目描述-5"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text">题目描述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#代码实现-5"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text">3. 代码实现</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#没有空间优化"><span class="toc_mobile_items-number">6.2.1.</span> <span class="toc_mobile_items-text">3.1 没有空间优化</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#有空间优化"><span class="toc_mobile_items-number">6.2.2.</span> <span class="toc_mobile_items-text">3.2 有空间优化</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#解码方法"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">91. 解码方法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目表述"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text">题目表述</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#然后说一下空间优化的问题"><span class="toc_mobile_items-number">7.1.1.</span> <span class="toc_mobile_items-text">然后说一下空间优化的问题。</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#代码实现-6"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text">代码实现</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#leetcode-152.-乘积最大子序列"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">Leetcode 152. 乘积最大子序列</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目描述-6"><span class="toc_mobile_items-number">8.1.</span> <span class="toc_mobile_items-text">1.题目描述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#代码实现-7"><span class="toc_mobile_items-number">8.2.</span> <span class="toc_mobile_items-text">代码实现</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#dfs剪枝-1"><span class="toc_mobile_items-number">8.2.1.</span> <span class="toc_mobile_items-text">dfs+剪枝</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#动态规划-1"><span class="toc_mobile_items-number">8.2.2.</span> <span class="toc_mobile_items-text">动态规划</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#leetcode-300.-最长上升子序列"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">Leetcode 300. 最长上升子序列</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目描述-7"><span class="toc_mobile_items-number">9.1.</span> <span class="toc_mobile_items-text">题目描述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#代码实现-8"><span class="toc_mobile_items-number">9.2.</span> <span class="toc_mobile_items-text">代码实现</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#柱状图中最大的矩形"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text">84. 柱状图中最大的矩形</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目描述-8"><span class="toc_mobile_items-number">10.1.</span> <span class="toc_mobile_items-text">题目描述</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#接下来"><span class="toc_mobile_items-number">10.1.1.</span> <span class="toc_mobile_items-text">接下来</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#代码实现-9"><span class="toc_mobile_items-number">10.2.</span> <span class="toc_mobile_items-text">代码实现</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#leetcode-85.-最大矩形"><span class="toc_mobile_items-number">11.</span> <span class="toc_mobile_items-text">Leetcode 85. 最大矩形</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目描述-9"><span class="toc_mobile_items-number">11.1.</span> <span class="toc_mobile_items-text">题目描述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#代码实现-10"><span class="toc_mobile_items-number">11.2.</span> <span class="toc_mobile_items-text">代码实现</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#二维区域和检索---矩阵不可变"><span class="toc_mobile_items-number">12.</span> <span class="toc_mobile_items-text">304. 二维区域和检索 - 矩阵不可变</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目描述-10"><span class="toc_mobile_items-number">12.1.</span> <span class="toc_mobile_items-text">题目描述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目描述-11"><span class="toc_mobile_items-number">12.2.</span> <span class="toc_mobile_items-text">题目描述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#解题思路-1"><span class="toc_mobile_items-number">12.3.</span> <span class="toc_mobile_items-text">解题思路</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#leetcode-5206.-删除字符串中的所有相邻重复项-ii"><span class="toc_mobile_items-number">13.</span> <span class="toc_mobile_items-text">Leetcode 5206. 删除字符串中的所有相邻重复项 II</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目描述-12"><span class="toc_mobile_items-number">13.1.</span> <span class="toc_mobile_items-text">题目描述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目描述-13"><span class="toc_mobile_items-number">13.2.</span> <span class="toc_mobile_items-text">题目描述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#代码实现-11"><span class="toc_mobile_items-number">13.3.</span> <span class="toc_mobile_items-text">代码实现</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#leetcode-1223.-掷骰子模拟"><span class="toc_mobile_items-number">14.</span> <span class="toc_mobile_items-text">Leetcode 1223. 掷骰子模拟</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目描述-14"><span class="toc_mobile_items-number">14.1.</span> <span class="toc_mobile_items-text">题目描述</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#leetcode-401.-二进制手表"><span class="toc_mobile_items-number">15.</span> <span class="toc_mobile_items-text">Leetcode 401. 二进制手表</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#题目描述-15"><span class="toc_mobile_items-number">15.1.</span> <span class="toc_mobile_items-text">题目描述</span></a></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#单词拆分"><span class="toc-number">1.</span> <span class="toc-text">139. 单词拆分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述"><span class="toc-number">1.1.</span> <span class="toc-text">1.题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码实现"><span class="toc-number">1.2.</span> <span class="toc-text">代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#动态规划"><span class="toc-number">1.2.1.</span> <span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dfs剪枝"><span class="toc-number">1.2.2.</span> <span class="toc-text">dfs+剪枝</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#最长回文子串"><span class="toc-number">2.</span> <span class="toc-text">5. 最长回文子串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#解题思路"><span class="toc-number">2.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码实现-1"><span class="toc-number">2.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#丑数-i"><span class="toc-number">3.</span> <span class="toc-text">263. 丑数 I</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-1"><span class="toc-number">3.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#打家劫舍i"><span class="toc-number">3.2.</span> <span class="toc-text">1.打家劫舍I</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-2"><span class="toc-number">3.2.1.</span> <span class="toc-text">1.1题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现-2"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.3代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#穿过迷宫的最少移动次数"><span class="toc-number">4.</span> <span class="toc-text">5208. 穿过迷宫的最少移动次数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-3"><span class="toc-number">4.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码实现-3"><span class="toc-number">4.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-120.-三角形最小路径和"><span class="toc-number">5.</span> <span class="toc-text">Leetcode 120. 三角形最小路径和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-4"><span class="toc-number">5.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码实现-4"><span class="toc-number">5.2.</span> <span class="toc-text">代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#不带空间优化"><span class="toc-number">5.2.1.</span> <span class="toc-text">不带空间优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#空间优化"><span class="toc-number">5.2.2.</span> <span class="toc-text">空间优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-435.-无重叠区间"><span class="toc-number">6.</span> <span class="toc-text">Leetcode 435. 无重叠区间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-5"><span class="toc-number">6.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码实现-5"><span class="toc-number">6.2.</span> <span class="toc-text">3. 代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#没有空间优化"><span class="toc-number">6.2.1.</span> <span class="toc-text">3.1 没有空间优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有空间优化"><span class="toc-number">6.2.2.</span> <span class="toc-text">3.2 有空间优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#解码方法"><span class="toc-number">7.</span> <span class="toc-text">91. 解码方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目表述"><span class="toc-number">7.1.</span> <span class="toc-text">题目表述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#然后说一下空间优化的问题"><span class="toc-number">7.1.1.</span> <span class="toc-text">然后说一下空间优化的问题。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码实现-6"><span class="toc-number">7.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-152.-乘积最大子序列"><span class="toc-number">8.</span> <span class="toc-text">Leetcode 152. 乘积最大子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-6"><span class="toc-number">8.1.</span> <span class="toc-text">1.题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码实现-7"><span class="toc-number">8.2.</span> <span class="toc-text">代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dfs剪枝-1"><span class="toc-number">8.2.1.</span> <span class="toc-text">dfs+剪枝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态规划-1"><span class="toc-number">8.2.2.</span> <span class="toc-text">动态规划</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-300.-最长上升子序列"><span class="toc-number">9.</span> <span class="toc-text">Leetcode 300. 最长上升子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-7"><span class="toc-number">9.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码实现-8"><span class="toc-number">9.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#柱状图中最大的矩形"><span class="toc-number">10.</span> <span class="toc-text">84. 柱状图中最大的矩形</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-8"><span class="toc-number">10.1.</span> <span class="toc-text">题目描述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#接下来"><span class="toc-number">10.1.1.</span> <span class="toc-text">接下来</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码实现-9"><span class="toc-number">10.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-85.-最大矩形"><span class="toc-number">11.</span> <span class="toc-text">Leetcode 85. 最大矩形</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-9"><span class="toc-number">11.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码实现-10"><span class="toc-number">11.2.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二维区域和检索---矩阵不可变"><span class="toc-number">12.</span> <span class="toc-text">304. 二维区域和检索 - 矩阵不可变</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-10"><span class="toc-number">12.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-11"><span class="toc-number">12.2.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解题思路-1"><span class="toc-number">12.3.</span> <span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-5206.-删除字符串中的所有相邻重复项-ii"><span class="toc-number">13.</span> <span class="toc-text">Leetcode 5206. 删除字符串中的所有相邻重复项 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-12"><span class="toc-number">13.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-13"><span class="toc-number">13.2.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码实现-11"><span class="toc-number">13.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-1223.-掷骰子模拟"><span class="toc-number">14.</span> <span class="toc-text">Leetcode 1223. 掷骰子模拟</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-14"><span class="toc-number">14.1.</span> <span class="toc-text">题目描述</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode-401.-二进制手表"><span class="toc-number">15.</span> <span class="toc-text">Leetcode 401. 二进制手表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-15"><span class="toc-number">15.1.</span> <span class="toc-text">题目描述</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png)"><div id="post-info"><div id="post-title"><div class="posttitle">LeetCode题目</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-12-01<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-12-04</time><div class="post-meta-wordcount"><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="单词拆分">139. 单词拆分</h1>
<h2 id="题目描述">1.题目描述</h2>
<p><em>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： 拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。 示例 1： 输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;] 输出: true 解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</em> ## 2.解题思路 这道题跟前面的[解码方法]一题非常非常地像。用<span class="math inline">\(dp[i][j]\)</span>表示字符串<span class="math inline">\(s[i:j]\)</span>是否可拆分，是为1，否为0。状态转移方程如下： <span class="math display">\[
dp[i]=\left \{ \begin{array}{cl} 1 &amp;i&gt;j\\ dp[i][j-k-1]\ and\ s[j-k:j]\ in\ wordDict&amp;i\neq j \end{array} \right .
\]</span> 其中<span class="math inline">\(0\leq k\leq j-i\)</span>。 然后我发现，这道题都用不着<span class="math inline">\(i\)</span>，直接用<span class="math inline">\(dp[j]\)</span>表示字符串<span class="math inline">\(s[0:j]\)</span>是否可拆分，所以公式改为： <span class="math display">\[
dp[j]=\begin{cases}1&amp; i&gt;j\\ dp[j-k-1]\ and\ s[j-k:j]\ in\ wordDict &amp; otherwise\end{cases}
\]</span></p>
<p>其中<span class="math inline">\(0\leq k\leq j\)</span>。 ## 3.代码实现 ### 3.1记忆化搜索 方便理解 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1050</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDp</span><span class="params">(<span class="keyword">int</span> j, <span class="built_in">string</span>&amp; s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> &gt; j) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (dp[j] != <span class="number">-1</span>) <span class="keyword">return</span> dp[j];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j; k++) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp = find(wordDict.begin(), wordDict.end(), s.substr(j-k, k+<span class="number">1</span>)) != wordDict.end();</span><br><span class="line"><span class="keyword">if</span> (getDp(j-k<span class="number">-1</span>, s, wordDict) &amp;&amp; tmp) <span class="keyword">return</span> dp[j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">return</span> getDp(s.length()<span class="number">-1</span>, s, wordDict);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ### 3.2动态规划 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1050</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j; k++) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp = find(wordDict.begin(), wordDict.end(), s.substr(j-k, k+<span class="number">1</span>)) != wordDict.end();</span><br><span class="line"><span class="keyword">if</span> (j-k<span class="number">-1</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">dp[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">dp[j] = dp[j-k<span class="number">-1</span>] &amp;&amp; tmp;</span><br><span class="line"><span class="keyword">if</span> (dp[j] == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[s.length()<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> # 279. 完全平方数 ## 题目描述 <em>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例 1: 输入: n = 12 输出: 3 解释: 12 = 4 + 4 + 4. 示例 2: 输入: n = 13 输出: 2 解释: 13 = 4 + 9.</em> ## 解题思路 ### 动态规划 用<span class="math inline">\(dp[i]\)</span>表示组成<span class="math inline">\(i\)</span>需要的完全平方数的最少个数。状态转移方程是： <span class="math display">\[
dp[i]=
\left \{
\begin{array}{lr}
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ i=0\\
min\{dp[i-j^2]+1\ |\ i-j^2\geq 0\}\ \ \ \ i\neq0
\end{array}
\right .
\]</span></p>
<p>其中<span class="math inline">\(j=[1,2,3...]\)</span>。 ### dfs+剪枝 dfs就比较好理解了。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> T, <span class="keyword">int</span> cur)</span> </span>&#123; <span class="comment">//目标是T，当前深度为cur</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 搜索过程如下： <img data-src="/images/1570118110.209162.jpg" class="lazyload"></p>
<h2 id="代码实现">代码实现</h2>
<h3 id="动态规划">动态规划</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> *dp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> m = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; i-k*k&gt;=<span class="number">0</span>; k++) &#123;</span><br><span class="line">m = min(m, dp[i-k*k]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">dp[i] = m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = dp[n];</span><br><span class="line"><span class="keyword">delete</span>[] dp;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="dfs剪枝">dfs+剪枝</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> T, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (T &lt; <span class="number">0</span> || cur &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (T == <span class="number">0</span>) &#123;</span><br><span class="line">ans = cur;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k = <span class="keyword">int</span>(<span class="built_in">sqrt</span>(T));</span><br><span class="line"><span class="keyword">for</span> (; k &gt;=<span class="number">1</span>; k--) &#123;</span><br><span class="line">dfs(T-k*k, cur+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">ans = <span class="number">9999999</span>;</span><br><span class="line">dfs(n, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="最长回文子串">5. 最长回文子串</h1>
<h2 id="解题思路">解题思路</h2>
<p>定义：</p>
<p><span class="math display">\[
dp[i][j]=
\begin{cases}
0,s[i,j]不是回文串\\
1,s[i,j]是回文串
\end{cases}
\]</span></p>
<p>状态转移方程：</p>
<p><span class="math display">\[
dp[i][j]=
\begin{cases}
dp[i+1][j-1],s[i]=s[j]\\
dp[i+1][j]\ or\ dp[i][j-1],s[i]\neq s[j]
\end{cases}
\]</span></p>
<p>举个例子：<em>输入: &quot;babad&quot; 输出: &quot;bab&quot; 注意: &quot;aba&quot; 也是一个有效答案。</em></p>
<p>初始化<span class="math inline">\(dp[i][j]=1\ (i&gt;=j)\)</span>，因为空串或者长度为1的字符串肯定是回文串。 也就是下图这样： <img data-src="/images/1569510358.068145.png" class="lazyload"> <img data-src="/images/1569510358.068145.png" class="lazyload"> 然后在看那个状态转移方程，搞明白要求一个<span class="math inline">\(dp[i][j]\)</span>需要用到的的是那些元素。如下图： <img data-src="/images/1569510588.185978.png" class="lazyload"> 可以看出，要求<span class="math inline">\(dp[i][j]\)</span>，需要知道跟他它紧挨着的左下角的三个元素，而我们最终要求的是整个串的最长回文串，所以需要求到<span class="math inline">\(dp[0][s.length-1]\)</span>。也就是下面蓝色星星这个位置：<img data-src="/images/1569510927.525995.png" class="lazyload"> 说到现在，整个状态转移的过程就差不多明了了： <img data-src="/images/1569511340.534351.png" class="lazyload"> 就这么斜着，一层一层地，直到到达最右上角的位置。 上面例子的最后状态就是： <img data-src="/images/1569511540.192087.png" class="lazyload"> 下一步就是怎么把回文串弄出来，方法是回溯，从离右上角最近的1开始，往对角线的方向走，如果其左下角为1，则直接移动到左下角，如果为0，则考虑往右或者往下走。经过的路径就是回文串的一半。 <img data-src="/images/1569511983.60891.png" class="lazyload"> <img data-src="/images/1569512200.882645.png" class="lazyload"></p>
<h2 id="代码实现-1">代码实现</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1050</span>][<span class="number">1050</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123; <span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.length(); j++)</span><br><span class="line">dp[i][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> last_i=<span class="number">0</span>, last_j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面开始一步一步地逼近dp[0][s.length()-1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; s.length(); k++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length()-k; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> j = i + k;</span><br><span class="line"><span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dp[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (dp[i][j] == <span class="number">1</span>) &#123; <span class="comment">//记下最后一个是回文串的位置，方便回溯</span></span><br><span class="line">last_i = i;</span><br><span class="line">last_j = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = last_i, j = last_j;</span><br><span class="line"><span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[i+<span class="number">1</span>][j<span class="number">-1</span>] == dp[i+<span class="number">1</span>][j<span class="number">-1</span>]) &#123;</span><br><span class="line">ans += s[i];</span><br><span class="line">i++;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dp[i][j<span class="number">-1</span>] == dp[i][j]) &#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dp[i+<span class="number">1</span>][j] == dp[i][j]) &#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> t = ans;</span><br><span class="line"><span class="keyword">if</span> (i == j) ans += s[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = t.length()<span class="number">-1</span>; k &gt;= <span class="number">0</span>; k--) ans += t[k];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="丑数-i">263. 丑数 I</h1>
<h2 id="题目描述-1">题目描述</h2>
<p><em>编写一个程序判断给定的数是否为丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例 1: 输入: 6 输出: true 解释: 6 = 2 × 3</em> ## 代码实现 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (num % <span class="number">5</span> == <span class="number">0</span>) num /= <span class="number">5</span>;</span><br><span class="line"><span class="keyword">while</span> (num % <span class="number">3</span> == <span class="number">0</span>) num /= <span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span> (num % <span class="number">2</span> == <span class="number">0</span>) num /= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> num == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> # 264. 丑数 II ## 题目描述 <em>编写一个程序，找出第 n 个丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例: 输入: n = 10 输出: 12 解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明: 1 是丑数。 n 不超过1690。</em> ## 代码实现 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2000</span>];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> l2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> l3 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> l5 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">dp[i] = min(dp[l2]*<span class="number">2</span>, min(dp[l3]*<span class="number">3</span>, dp[l5]*<span class="number">5</span>));</span><br><span class="line"><span class="keyword">while</span> (dp[l2]*<span class="number">2</span> &lt;= dp[i]) l2++;</span><br><span class="line"><span class="keyword">while</span> (dp[l3]*<span class="number">3</span> &lt;= dp[i]) l3++;</span><br><span class="line"><span class="keyword">while</span> (dp[l5]*<span class="number">5</span> &lt;= dp[i]) l5++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> # Leetcode 198. 打家劫舍 I/II</p>
<p><img data-src="/images/WX20191002-181655@2x.png" class="lazyload"></p>
<h2 id="打家劫舍i">1.打家劫舍I</h2>
<h3 id="题目描述-2">1.1题目描述</h3>
<p><em>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 输入: [1,2,3,1] 输出: 4 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。</em> ### 1.2解题思路 妥妥的动态规划。用<span class="math inline">\(dp[i][0]\)</span>表示在<span class="math inline">\(0\)</span>到<span class="math inline">\(i\)</span>号屋子中，不抢劫第<span class="math inline">\(i\)</span>号屋子所能获得的最大现金；<span class="math inline">\(dp[i][i]\)</span>表示在<span class="math inline">\(0\)</span>到<span class="math inline">\(i\)</span>号屋子中，抢劫第<span class="math inline">\(i\)</span>号屋子所能获得的最大现金。则状态转移方程如下： <span class="math display">\[
\begin{array}{lr}
dp[i][0]=
\left \{
\begin{array}{lr}
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ i=0\\
max\{dp[i-1][0],dp[i-1][1]\}\ \ \ \ i\neq0
\end{array}
\right .\\
~\\
dp[i][1]=
\left \{
\begin{array}{lr}
\ \ \ \ \ \ \ \ \ \ \ \ \ nums[i]\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ i=0\\
dp[i-1][0]+nums[i]\ \ \ \ i\neq0
\end{array}
\right .
\end{array}
\]</span></p>
<p>稍微说明一下，假如第<span class="math inline">\(i\)</span>间房屋不抢，则第<span class="math inline">\(i-1\)</span>间房屋可以抢也可以不抢，对应着公式<code>$dp[i][0]=max\{dp[i-1][0],dp[i-1][1]\}$</code>；假如第<span class="math inline">\(i\)</span>间房屋要抢，则第<span class="math inline">\(i-1\)</span>间房屋必然不能抢，对应着公式<code>$dp[i][1]=dp[i-1][0]+nums[i]$</code>； ### 1.3代码实现 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">9999</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums.size() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">dp[i][<span class="number">1</span>] = nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + nums[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max(dp[nums.size()<span class="number">-1</span>][<span class="number">0</span>], dp[nums.size()<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ## 2.打家劫舍II ### 2.1题目描述 <em>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 输入: [2,3,2] 输出: 3 解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</em> ### 2.2解题思路 跟第一道题相比，不同之处就在第一间和最后一间房屋变成相邻的了。所以这里就有了四种情况： 1. 第一间和最后一间都不抢 2. 抢第一间，不抢最后一间 3. 不抢第一间，抢最后一间 4. 都抢</p>
<p>前三种情况完成可以用第一题的代码去解决。主要是第四种情况有点不一样。因为现在第一间跟最后一间变成相邻的了，所有现在需要从其二者中选择去掉一个。那么这个问题就分成了两个问题： 1) 从第一间房到倒数第二间房所能获得到最大现金 2) 从第二间房到最后一间房所能获得到最大现金</p>
<h3 id="代码实现-2">2.3代码实现</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">9999</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums.size() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">dp[i][<span class="number">1</span>] = nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + nums[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max(dp[nums.size()<span class="number">-1</span>][<span class="number">0</span>], dp[nums.size()<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums.size() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = rob1(nums);</span><br><span class="line"><span class="keyword">if</span> (ans == dp[nums.size()<span class="number">-1</span>][<span class="number">0</span>]) &#123;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (nums.size() &lt;=<span class="number">1</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> last = nums[nums.size()<span class="number">-1</span>];</span><br><span class="line">nums.pop_back();</span><br><span class="line"><span class="keyword">int</span> ans1 = rob1(nums);</span><br><span class="line"></span><br><span class="line">nums.push_back(last);</span><br><span class="line">nums.erase(nums.begin());</span><br><span class="line"><span class="keyword">int</span> ans2 = rob1(nums);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max(ans1, ans2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="穿过迷宫的最少移动次数">5208. 穿过迷宫的最少移动次数</h1>
<h2 id="题目描述-3">题目描述</h2>
<p><img data-src="/images/WX20190929-233936@2x.png" class="lazyload"> <img data-src="/images/WX20190929-234131@2x.png" class="lazyload"> ## 思想 想法很简单，就是用BFS一层一层的搜索就可以。但针对这个问题，有些地方需要改变下。 ### 首先是当前位置 以前在一个二维地图上进行BFS，当前位置都是用<span class="math inline">\((i,j)\)</span>这样一个坐标表示的，但现在这条小蛇独占了2个格子，也就是需要用两个坐标来表示，即<span class="math inline">\((i_1,j_1),(i_2,j_2)\)</span>，约定第一个坐标表示蛇的尾部，第二个坐标表示蛇的头部。为了方便实现，我们定义一个结构体： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> a, b, c, d;</span><br><span class="line">Node() &#123;&#125;</span><br><span class="line">Node(<span class="keyword">int</span> _a, <span class="keyword">int</span> _b, <span class="keyword">int</span> _c, <span class="keyword">int</span> _d) : a(_a), b(_b), c(_c), d(_d) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 其中<code>(a,b)</code>对应着<span class="math inline">\((i_1,j_1)\)</span>，同理，<code>(c,d)</code>对应着<span class="math inline">\((i_2,j_2)\)</span>。 ### 然后是记录已经访问过的“小蛇的位置” 以前都是用<code>visited[i][j]</code>来表示<span class="math inline">\((i,j)\)</span>有没有被访问过，而在这里，我定义了一个集合: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;Node&gt; visited;</span><br></pre></td></tr></table></figure> ### 再有就是“如何走” 从某个位置可以走的方案一共四种，分别是： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Node try_right =        Node(p.a, p.b+<span class="number">1</span>, p.c, p.d+<span class="number">1</span>);</span><br><span class="line">Node try_down =       Node(p.a+<span class="number">1</span>, p.b, p.c+<span class="number">1</span>, p.d);</span><br><span class="line">Node try_clockwise = Node(p.a, p.b, p.a+<span class="number">1</span>, p.b);</span><br><span class="line">Node try_anti =         Node(p.a, p.b, p.a, p.b+<span class="number">1</span>);</span><br></pre></td></tr></table></figure> ## 代码实现 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> a, b, c, d;</span><br><span class="line">Node() &#123;&#125;</span><br><span class="line">Node(<span class="keyword">int</span> _a, <span class="keyword">int</span> _b, <span class="keyword">int</span> _c, <span class="keyword">int</span> _d) : a(_a), b(_b), c(_c), d(_d) &#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;n) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (a != n.a) <span class="keyword">return</span> a &lt; n.a;</span><br><span class="line"><span class="keyword">if</span> (b != n.b) <span class="keyword">return</span> b &lt; n.b;</span><br><span class="line"><span class="keyword">if</span> (c != n.c) <span class="keyword">return</span> c &lt; n.c;</span><br><span class="line"><span class="keyword">if</span> (d != n.d) <span class="keyword">return</span> d &lt; n.d;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumMoves</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">Node start = Node(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">set</span>&lt;Node&gt; visited;</span><br><span class="line">visited.insert(start);</span><br><span class="line"><span class="built_in">deque</span>&lt;Node&gt; d;</span><br><span class="line">d.push_back(start);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!d.empty()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = d.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len; i++) &#123;</span><br><span class="line">Node &amp;p = d.front();</span><br><span class="line"><span class="keyword">if</span> (p.a == (m<span class="number">-1</span>) &amp;&amp; p.c == (m<span class="number">-1</span>) &amp;&amp; p.b == (n<span class="number">-2</span>) &amp;&amp; p.d == (n<span class="number">-1</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node try_right =     Node(p.a, p.b+<span class="number">1</span>, p.c, p.d+<span class="number">1</span>);</span><br><span class="line">Node try_down =      Node(p.a+<span class="number">1</span>, p.b, p.c+<span class="number">1</span>, p.d);</span><br><span class="line">Node try_clockwise = Node(p.a, p.b, p.a+<span class="number">1</span>, p.b);</span><br><span class="line">Node try_anti =      Node(p.a, p.b, p.a, p.b+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p.a == p.c) &#123; <span class="comment">//小蛇是横着的</span></span><br><span class="line"><span class="keyword">if</span> (try_right.d &lt; n &amp;&amp; grid[try_right.c][try_right.d] != <span class="number">1</span> &amp;&amp; visited.find(try_right) == visited.end()) &#123;</span><br><span class="line">visited.insert(try_right);</span><br><span class="line">d.push_back(try_right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (try_down.a &lt; m &amp;&amp; grid[try_down.a][try_down.b] != <span class="number">1</span> &amp;&amp; grid[try_down.c][try_down.d] != <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (visited.find(try_down) == visited.end()) &#123;</span><br><span class="line">visited.insert(try_down);</span><br><span class="line">d.push_back(try_down);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (visited.find(try_clockwise) == visited.end()) &#123;</span><br><span class="line">visited.insert(try_clockwise);</span><br><span class="line">d.push_back(try_clockwise);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">//小蛇是竖着的</span></span><br><span class="line"><span class="keyword">if</span> (try_down.c &lt; m &amp;&amp; grid[try_down.c][try_down.d] != <span class="number">1</span> &amp;&amp; visited.find(try_down) == visited.end()) &#123;</span><br><span class="line">visited.insert(try_down);</span><br><span class="line">d.push_back(try_down);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (try_right.b &lt; n &amp;&amp; grid[try_right.a][try_right.b] != <span class="number">1</span> &amp;&amp; grid[try_right.c][try_right.d] != <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (visited.find(try_right) == visited.end()) &#123;</span><br><span class="line">visited.insert(try_right);</span><br><span class="line">d.push_back(try_right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (visited.find(try_anti) == visited.end()) &#123;</span><br><span class="line">visited.insert(try_anti);</span><br><span class="line">d.push_back(try_anti);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">d.pop_front();</span><br><span class="line">&#125;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> # Leetcode 5099. 验证回文字符串 III ## 题目描述 <em>给出一个字符串 s 和一个整数 k，请你帮忙判断这个字符串是不是一个「K 回文」。 所谓「K 回文」：如果可以通过从字符串中删去最多 k 个字符将其转换为回文，那么这个字符串就是一个「K 回文」。 示例： 输入：s = &quot;abcdeca&quot;, k = 2 输出：true 解释：删除字符 “b” 和 “e”。 提示： 1 &lt;= s.length &lt;= 1000 s 中只含有小写英文字母 1 &lt;= k &lt;= s.length</em> ## 解题思路 动态规划。 一开始是想着用记忆搜索那种方法，但是内存超限，然后用动态规划，时间超限。。。最后灵机一动，巧妙一变，问题引刃而解。 用<span class="math inline">\(dp[i][j]\)</span>表示将字符串<span class="math inline">\(s[i:j]\)</span>变成回文需要的最少操作数。状态转移方程如下： <span class="math display">\[
dp[i][j]=
\left \{
\begin{array}{clr}
0&amp; i\geq j\\
dp[i+1][j-1]&amp; i &lt; j,s[i]=s[j]\\
min\{dp[i+1][j],dp[i][j-1]\}&amp; i &lt; j,s[i]\neq s[j]
\end{array}
\right .
\]</span></p>
<p>这样就把k巧妙的去掉了，好理解，公式简洁，代码简单。 至于动态转移方程的具体过程讲解，请看<a href="#最长回文子串">5. 最长回文子串</a>，二者非常非常地像。</p>
<h2 id="代码实现-3">代码实现</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidPalindrome</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1050</span>][<span class="number">1050</span>];</span><br><span class="line"><span class="keyword">int</span> n = s.length();</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; n; k++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n<span class="number">-1</span>-k; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> j = i+k;</span><br><span class="line"><span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = min(dp[i+<span class="number">1</span>][j], dp[i][j<span class="number">-1</span>]) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>] &lt;= k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-120.-三角形最小路径和">Leetcode 120. 三角形最小路径和</h1>
<h2 id="题目描述-4">题目描述</h2>
<p><em>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</em> <em>例如，给定三角形： [ [2], [3,4], [6,5,7], [4,1,8,3]] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</em> ## 解题思路 动态规划，用<span class="math inline">\(dp[i][j]\)</span>表示从顶点到达<span class="math inline">\((i, j)\)</span>点的最短路径和。状态转移方程如下： <span class="math display">\[
dp[i][j]=
\left \{
\begin{array}{clr}
triangle[i][j]&amp; i=0\\
triangle[i][j]+dp[i-1][j]&amp; j=0\\
triangle[i][j]+dp[i-1][j-1]&amp; j=triangle[i].length-1\\
triangle[i][j]+min\{dp[i-1][j],dp[i-1][j-1]\}&amp; 0 &lt; j &lt; triangle[i].length-1
\end{array}
\right .
\]</span></p>
<p><img data-src="/images/1569908670.916558.png" class="lazyload"> 可以看出来，更新第<span class="math inline">\(i\)</span>行只需要用到第<span class="math inline">\(i-1\)</span>行，所以可以进一步优化空间。 用<span class="math inline">\(dp[j]\)</span>表示从顶点到达<span class="math inline">\((i, j)\)</span>点的最短路径和,优化之后的公式如下： <span class="math display">\[
dp[j]=
\left \{
\begin{array}{clr}
triangle[i][j]&amp; i=0\\
triangle[i][j]+dp[j]&amp; j=0\\
triangle[i][j]+dp[j-1]&amp; j=triangle[i].length-1\\
triangle[i][j]+min\{dp[j],dp[j-1]\}&amp; 0 &lt; j &lt; triangle[i].length-1
\end{array}
\right .
\]</span></p>
<p>其中，<span class="math inline">\(i=\{0,1,2,...,n-1\}\)</span> <span class="math inline">\(j=\{triangle[i].length-1, triangle[i].length-2,...,0\}\)</span> 注意，<span class="math inline">\(j\)</span>必须是<strong>降序</strong>，这是因为求<span class="math inline">\(dp[j]\)</span>需要用到<span class="math inline">\(dp[j-1]\)</span>。如果求<span class="math inline">\(dp[j]\)</span>需要用到<span class="math inline">\(dp[j+1]\)</span>，则<span class="math inline">\(j\)</span>需要是升序。</p>
<h2 id="代码实现-4">代码实现</h2>
<h3 id="不带空间优化">不带空间优化</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span> &lt; <span class="built_in">vector</span> &lt; <span class="keyword">int</span> &gt; &gt; &amp; triangle)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1050</span>][<span class="number">1050</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n = triangle.size();</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (triangle[<span class="number">0</span>].size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; triangle[i].size(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j] + triangle[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j == triangle[i].size()<span class="number">-1</span>) &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + triangle[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = triangle[i][j] + min(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = dp[n<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; triangle[n<span class="number">-1</span>].size(); j++) &#123;</span><br><span class="line">ans = min(ans, dp[n<span class="number">-1</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="空间优化">空间优化</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1050</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n = triangle.size();</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (triangle[<span class="number">0</span>].size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">dp[<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = triangle[i].size()<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">dp[j] = dp[j] + triangle[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j == triangle[i].size()<span class="number">-1</span>) &#123;</span><br><span class="line">dp[j] = dp[j<span class="number">-1</span>] + triangle[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">dp[j] = triangle[i][j] + min(dp[j], dp[j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = dp[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; triangle[n<span class="number">-1</span>].size(); j++) &#123;</span><br><span class="line">ans = min(ans, dp[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-435.-无重叠区间">Leetcode 435. 无重叠区间</h1>
<h2 id="题目描述-5">题目描述</h2>
<p><em>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。 注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 示例 1: 输入: [ [1,2], [2,3], [3,4], [1,3] ] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。</em> ## 解题思路 贪心思想。这种遇见的问题，首先按照端点或者区间长度排个序往往能起到事半功倍的效果。 <a href="https://leetcode-cn.com/problems/non-overlapping-intervals/solution/wu-zhong-die-qu-jian-by-leetcode/" target="_blank" rel="noopener">官方题解</a>里有详细解题说明。 ## 代码实现 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a[<span class="number">0</span>] &lt;= b[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !(a[<span class="number">1</span>] &lt;= b[<span class="number">0</span>] || b[<span class="number">1</span>] &lt;= a[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (intervals.size() &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line"><span class="comment">// for (auto &amp;au : intervals) &#123;</span></span><br><span class="line"><span class="comment">//     cout &lt;&lt; au[0] &lt;&lt; " " &lt;&lt; au[1] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (judge(intervals[pre], intervals[i])) &#123;</span><br><span class="line"><span class="keyword">if</span> (intervals[pre][<span class="number">0</span>] &lt;= intervals[i][<span class="number">0</span>] &amp;&amp; intervals[pre][<span class="number">1</span>] &gt;= intervals[i][<span class="number">1</span>]) &#123;</span><br><span class="line">pre = i;</span><br><span class="line">ans += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ans += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">pre = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> # 542. 01 矩阵 ## 题目描述 <em>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。 两个相邻元素间的距离为 1 。 注意： 1. 给定矩阵的元素个数不超过 10000。 2. 给定矩阵中至少有一个元素是 0。 3. 矩阵中的元素只在四个方向上相邻: 上、下、左、右。</em> ### 一开始想的是 一开始想的是BFS，遍历数组，如果当前元素是1，则从当前位置开始BFS，这样的话，遍历数组用时<span class="math inline">\(O(n^2)\)</span>，BFS用时<span class="math inline">\(O(n^2)\)</span>，总体时间复杂度为<span class="math inline">\(O(n^4)\)</span>，感觉不太行。 ### 动态规划？ 突然起了个想法，也可能是前两天写的两篇博客都是关于动态规划的，就想着这个能不能用动态规划做呢？然后就想出了下面的东西（其实我不确定这是不是对的）。 用<span class="math inline">\(dp[i][j]\)</span>表示位于<span class="math inline">\((i,j)\)</span>的1到最近的 0 的距离。看一下下面的图： <img data-src="/images/1569678131.294707.png" class="lazyload"> 要求<span class="math inline">\(dp[i][j]\)</span>不就需要求它周围的这8个点的<span class="math inline">\(dp\)</span>值，再加上1或者2不就好了吗。公式如下： <span class="math display">\[
dp[i][j]=min
\left \{
\begin{array}{lr}
dp[i-1][j-1]+2,\\
dp[i-1][j]+1,\\
dp[i-1][j+1]+2,\\
dp[i][j-1]+1,\\
dp[i][j+1]+1,\\
dp[i+1][j-1]+2,\\
dp[i+1][j]+1,\\
dp[i+1][j+1]+2
\end{array}
\right .
\]</span></p>
<p>然后我发现这样还不够简单，再改改，去掉四个角点： <img data-src="/images/1569679002.365362.png" class="lazyload"> 然后公式就变成了： <span class="math display">\[
dp[i][j]=min
\left \{
\begin{array}{lr}
dp[i-1][j],\\
dp[i][j-1],\\
dp[i][j+1],\\
dp[i+1][j],\\
\end{array}
\right \}+1
\]</span></p>
<p>然后我又在想，初始状态是怎么弄呢？因为这个转移方程形式是从四周向着一个中心点收缩，所有有些点是一开始就应该被初始化，这些点就是<span class="math inline">\(matrix[i][j]=0\)</span>的点。 也即是首先把所有<span class="math inline">\(matrix[i][j]=0\)</span>的点的<span class="math inline">\(dp\)</span>值设为0，然后从以这些点为基础“广播”，如下图： <img data-src="/images/1569679807.91525.png" class="lazyload"> 上图中，蓝色的是初始<span class="math inline">\(dp\)</span>为0的点，紫色圈是不断进行状态转移，数字表示“广播”的距离。哎呦，这不就是BFS吗！？ ### 回到BFS 一开始想到BFS是以<span class="math inline">\(matrix[i][j]=1\)</span>的位置为起始位置进行BFS，不妨换一种思路：以<span class="math inline">\(matrix[i][j]=0\)</span>的位置为起始位置进行BFS，当遇到<span class="math inline">\(matrix[i][j]=1\)</span>的位置时，那么其<span class="math inline">\(dp\)</span>值就是BFS的层数。问题被巧妙地解决了。时间复杂度为<span class="math inline">\(O(n^2)\)</span>。 ### 小技巧 题目中告诉我们<strong>给定矩阵的元素个数不超过 10000</strong>，如果设置一个数组<code>int visited[10000][10000]</code>，这样内存不够用的，技巧是设置一个<code>int visited[10000]</code>，然后将位置<span class="math inline">\((i,j)\)</span>离散化处理，变成<span class="math inline">\(i*n+j\)</span>，其中<span class="math inline">\(n\)</span>是<span class="math inline">\(matrix\)</span>的列数。这样原来的<code>visited[i][j]=1</code>就变成了<code>visited[i*n+j]=1</code>。 ## 代码实现 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; updateMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> next[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans = matrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> visited[<span class="number">10002</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">deque</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; d;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size();;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">d.push_back(make_pair(i, j));</span><br><span class="line">visited[i*n+j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!d.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> len = d.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p = d.front();</span><br><span class="line">d.pop_front();</span><br><span class="line"><span class="keyword">int</span> i = p.first, j = p.second;</span><br><span class="line"><span class="keyword">if</span> (matrix[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">ans[i][j] = step;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">4</span>; t++) &#123;</span><br><span class="line"><span class="keyword">int</span> next_i = i+ next[t][<span class="number">0</span>], next_j = j + next[t][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (!(next_i &lt; <span class="number">0</span> || next_i &gt;= matrix.size() || next_j &lt; <span class="number">0</span> || next_j &gt;= matrix[<span class="number">0</span>].size() || visited[next_i*n+next_j] == <span class="number">1</span>)) &#123;</span><br><span class="line">d.push_back(make_pair(next_i, next_j));</span><br><span class="line">visited[next_i*n+next_j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">step++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> # 221. 最大正方形 ## 1. 题目描述 <em>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 示例: 输入: 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 输出: 4</em> ## 2. 解题思路 一开始是想和<a href="https://leetcode-cn.com/problems/maximal-rectangle/" target="_blank" rel="noopener">Leetoce 85. 最大矩阵</a>这道题一起做的，所以在设计动态规划数组时候就留了一手。但随后发现最大矩阵那道题用这样的动态规划不太好弄。所以最后我又重新做了一遍这道最大正方形的题，力求让公式更加简洁。 用<span class="math inline">\(dp[i][j]\)</span>表示以<span class="math inline">\((i,j)\)</span>为右下角的正方形的边长。 状态转移方程如下： <span class="math display">\[
dp[i][j]=
\left \{
\begin{array}{lr}
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ matrix[i][j]==1\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ i=0||j=0\\
min\{dp[i-1][j],dp[i-1][j-1],dp[i][j-1]\}+1\ \ \ \ otherwise
\end{array}
\right .
\]</span></p>
<p>意思就是求分别以<span class="math inline">\((i-1,j)\)</span>、<span class="math inline">\((i-1,j-1)\)</span>、<span class="math inline">\((i,j-1)\)</span>为右下角的正方形的交集的边长，如下图中阴影部分，就是紫色、蓝色、绿色三个正方形的交集。 <img data-src="/images/1570084835.03738.jpg" class="lazyload"> 然后就是空间优化，这里不详细说明了，请看代码。</p>
<h2 id="代码实现-5">3. 代码实现</h2>
<h3 id="没有空间优化">3.1 没有空间优化</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1050</span>][<span class="number">1050</span>];</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">int</span> m = matrix.size();</span><br><span class="line"><span class="keyword">if</span> (m &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>] == <span class="string">'1'</span>;</span><br><span class="line">ans = max(ans, dp[i][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = matrix[<span class="number">0</span>][j] == <span class="string">'1'</span>;</span><br><span class="line">ans = max(ans, dp[<span class="number">0</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">dp[i][j] = min(dp[i<span class="number">-1</span>][j], min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], dp[i][j<span class="number">-1</span>])) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans, dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans*ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="有空间优化">3.2 有空间优化</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1050</span>];</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">int</span> m = matrix.size();</span><br><span class="line"><span class="keyword">if</span> (m &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cur, pre;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (matrix[i][j] == <span class="string">'0'</span>) &#123;</span><br><span class="line">dp[j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">dp[j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">pre = dp[j];</span><br><span class="line">dp[j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cur = dp[j];</span><br><span class="line">dp[j] = min(dp[j], min(pre, dp[j<span class="number">-1</span>])) + <span class="number">1</span>;</span><br><span class="line">pre = cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans, dp[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans*ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="解码方法">91. 解码方法</h1>
<h2 id="题目表述">题目表述</h2>
<p><em>一条包含字母 A-Z 的消息通过以下方式进行了编码： 'A' -&gt; 1 'B' -&gt; 2 ... 'Z' -&gt; 26 给定一个只包含数字的非空字符串，请计算解码方法的总数。 示例 1: 输入: &quot;12&quot; 输出: 2 解释: 它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。 示例 2: 输入: &quot;226&quot; 输出: 3 解释: 它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/decode-ways 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</em></p>
<p>还是利用动态规划。但与上一题<a href="http://199.247.8.254/index.php/2019/09/27/leetcode-5-zuichanghuiwenzichuan/" target="_blank" rel="noopener">最长回文子串</a>不同的是，这道题的状态转移方程不一样，但都差不多。观察状态转移方程发现，可以将二维的数组压缩到一维。最后总结一下<strong>常见的状态转移方程的形式</strong>。 ps.弱弱地说一句，其实上一题也是可以优化，由<span class="math inline">\(m\times n\)</span>维变成<span class="math inline">\(2\times n\)</span>维的。 ### 下面开始吧 用<span class="math inline">\(dp[i][j]\)</span>表示字符串<span class="math inline">\(s[i:j]\)</span>编码的最大方案数。 ### 状态转移方程： <span class="math display">\[
dp[i][j]=max\{dp[i][j-k-1]\ |\ 1\leq s[j-k:j]\leq 26,0\leq k\leq min\{2,j-i+1\} \}
\]</span></p>
<p>我试着说明一下。 假设<span class="math inline">\(dp[i][j-1]\)</span>已经知道了，也就是说字符串<span class="math inline">\(s[i:j]\)</span>的编码方案数已知，现在考虑地第<span class="math inline">\(j\)</span>位字符。需要做的是，选择从<span class="math inline">\(j\)</span>位往前，选择<span class="math inline">\(k\)</span>位字符，将它们跟第<span class="math inline">\(j\)</span>位拼起来并看成一个整体，也就是将<span class="math inline">\(s[i:j]\)</span>分成<span class="math inline">\(s[i:j-k-1]\)</span>和<span class="math inline">\(s[j-k:j]\)</span>两个部分，注意，这样分的前提是<span class="math inline">\(s[j-k:j]\)</span>是可编码的，也就是对应着<span class="math inline">\(1\leq s[j-k:j]\leq 26\)</span>这个条件。举个例子，<span class="math inline">\(s=226\)</span>，现在考虑<span class="math inline">\(6\)</span>这一位，如下图： <img data-src="/images/1569601443.899273.png" class="lazyload"> 这是两种不同的方案，然后去这两中方案中的最大那一种就可以，也就是对应着公式中<span class="math inline">\(max\{dp[i][j-k-1]\}\)</span>的部分。 因为从1到26，最大就是2位数，所以<span class="math inline">\(k\)</span>最大是1，也就是最多往前选1个字符，又因为还需要保证<span class="math inline">\(s[i:j-k-1]\)</span>不为空，所以需要<span class="math inline">\(i\leq j-k-1\)</span>，即<span class="math inline">\(k\leq j-i+1\)</span>，这就对应了公式中<span class="math inline">\(0\leq k\leq min\{2,j-i+1\}\)</span>的部分。</p>
<h3 id="然后说一下空间优化的问题">然后说一下空间优化的问题。</h3>
<p>从上面的状态转移方程可以看出，求<span class="math inline">\(dp[i][j]\)</span>只需要第<span class="math inline">\(i\)</span>行<span class="math inline">\(j\)</span>左边的元素就行，用不着其他行的元素，所有可以二维降成一维。 <img data-src="/images/1569599998.240907.png" class="lazyload"> 降为一维后，还是进行跟原来类似的操作，只不过就是对这一维数组进行了多次操作，如下图。 <img data-src="/images/1569600450.99735.png" class="lazyload"> 优化之后的状态转移方程就变成了： <span class="math display">\[
dp[j]=max\{dp[j-k-1]\ |\ 1\leq s[j-k:j]\leq 26,0\leq k\leq min\{2,j-i+1\} \}\\
\]</span></p>
<p>其中<span class="math inline">\(i\)</span>表示当前是第几次操作。 ### 下面总结一下常见的状态转移形式，方程就不写了，记不住，就把图画一画吧。 紫色五角星表示要求的目标，蓝色表示求这个目标需要那些元素 第一类： <img data-src="/images/1569600833.496609.png" class="lazyload"> 第二类： <img data-src="/images/1569600867.514149.png" class="lazyload"> 第三类： <img data-src="/images/1569600906.421126.png" class="lazyload"> ## 代码实现 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s.length() &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; se &#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"10"</span>,</span><br><span class="line"><span class="string">"11"</span>, <span class="string">"12"</span>, <span class="string">"13"</span>, <span class="string">"14"</span>, <span class="string">"15"</span>, <span class="string">"16"</span>, <span class="string">"17"</span>, <span class="string">"18"</span>, <span class="string">"19"</span>, <span class="string">"20"</span>,</span><br><span class="line"><span class="string">"21"</span>, <span class="string">"22"</span>, <span class="string">"23"</span>, <span class="string">"24"</span>, <span class="string">"25"</span>, <span class="string">"26"</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">3050</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] != <span class="string">'0'</span>) &#123;</span><br><span class="line">dp[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m = s.length();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt; m; t++) &#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">i = m - t - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (j = i+<span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= min(<span class="number">1</span>, j-i+<span class="number">1</span>); k++) &#123;</span><br><span class="line"><span class="keyword">if</span> (se.find(s.substr(j-k, k+<span class="number">1</span>)) != se.end()) &#123;</span><br><span class="line"><span class="keyword">if</span> (j - k - <span class="number">1</span> &lt; i) &#123;</span><br><span class="line">cur += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cur += dp[j-k<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dp[j] = cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> # 接上一题 Leetcode 95. 不同的二叉搜索树 II ## 题目描述 <em>给定一个整数 n，生成所有由 1 ... n 为节点所组成的二叉搜索树。 实例 输入: 3 输出: [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]</em> ## 解题思路 这道题用不着动态规划，也用不着卡特兰数列，只要明白了树的构建过程，然后构建树就行了，就像是根据前序和中序序列构建树那样。 稍微需要注意的就是这里，左右子树组合的方法： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; l: left) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r: right) &#123;</span><br><span class="line">TreeNode *root = <span class="keyword">new</span> TreeNode(k);</span><br><span class="line">root-&gt;left = l;</span><br><span class="line">root-&gt;right = r;</span><br><span class="line">ans.push_back(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 代码实现 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode *left;</span></span><br><span class="line"><span class="comment">*     TreeNode *right;</span></span><br><span class="line"><span class="comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;TreeNode*&gt; build(<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;TreeNode*&gt; ans;</span><br><span class="line"><span class="keyword">if</span> (i &gt; j) &#123;</span><br><span class="line">ans.push_back(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; k++) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;TreeNode*&gt; left = build(i, k<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;TreeNode*&gt; right = build(k+<span class="number">1</span>, j);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; l: left) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r: right) &#123;</span><br><span class="line">TreeNode *root = <span class="keyword">new</span> TreeNode(k);</span><br><span class="line">root-&gt;left = l;</span><br><span class="line">root-&gt;right = r;</span><br><span class="line">ans.push_back(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;TreeNode*&gt; generateTrees(<span class="keyword">int</span> n) &#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;TreeNode*&gt; ans;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> build(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> # Leetcode 96. 不同的二叉搜索树 ## 题目描述 <em>给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？</em> ## 解题思路 ### 看图说话 假设<span class="math inline">\(n=3\)</span>，那么初始数组就是<span class="math inline">\([1,2,3]\)</span>。 首先从中选择一个数字作为根结点，可选择的点有3个，分别是<span class="math inline">\(1,2,3\)</span>。假设选择了<span class="math inline">\(1\)</span>，然后左子树即为空，再根据剩下的<span class="math inline">\([2,3]\)</span>用同样的方法构造右子树。过程如下图： <img data-src="/images/1569851804.47133.png" class="lazyload"> ### 用动态规划解释 用<span class="math inline">\(f[n]\)</span>表示从1到n，n个数能组成的二叉搜索树的数量。根据上面的二叉树生成过程可以得出： <span class="math display">\[
f[n]=
\left \{
\begin{array}{clr}
1&amp; n\leq 1\\
\sum\limits_{k=0}^{n-1}{f[k]\times f[n-k-1]} &amp; n&gt;1
\end{array}
\right .
\]</span></p>
<p>举个例子： <span class="math display">\[
f[5]=f[0]\times f[4]\\
=f[1]\times f[3]\\
=f[2]\times f[2]\\
=f[3]\times f[1]\\
=f[4]\times f[0]
\]</span></p>
<p>也没啥好解释的，找找规律就能写出公式了。 ### 继续动态规划 如果是二维的呢？ <span class="math display">\[
f(i,j)=
\left \{
\begin{array}{clr}
1&amp; i\geq j \\
\sum\limits_{k=i}^{j-1}f(i,k)\times f(k+1,j)&amp; i&lt;j
\end{array}
\right .
\]</span></p>
<p><img data-src="/images/1569853692.133241.png" class="lazyload"> 相同颜色是相互对应的。有兴趣的童鞋可以自行搜索“卡特兰数列”。</p>
<h2 id="代码实现-6">代码实现</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1050</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">f[i] += (f[k] * f[i-k<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-152.-乘积最大子序列">Leetcode 152. 乘积最大子序列</h1>
<h2 id="题目描述-6">1.题目描述</h2>
<p><em>给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。 示例 1: 输入: [2,3,-2,4] 输出: 6 解释: 子数组 [2,3] 有最大乘积 6。</em> ## 2.解题思路 个人感觉这道题非常地有意思，其实用不上动态规划，或者说不是那种正规的动态规划。这道题的关键在于“负负得正”。 准备两个数组 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> real_max[<span class="number">1050</span>];</span><br><span class="line"><span class="keyword">int</span> fake_max[<span class="number">1050</span>];</span><br></pre></td></tr></table></figure> <code>read_max[i]</code>表示以<code>nums[i]</code>结尾的子数组的<strong>真实</strong>最大乘积； <code>fake_max[i]</code>表示以<code>nums[i]</code>结尾的子数组的<strong>可能</strong>最大乘积； ## 3.代码实现 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> *real_max = <span class="keyword">new</span> <span class="keyword">int</span>[nums.size()];</span><br><span class="line"><span class="keyword">int</span> *fake_max = <span class="keyword">new</span> <span class="keyword">int</span>[nums.size()];</span><br><span class="line"></span><br><span class="line">real_max[<span class="number">0</span>] = fake_max[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a = nums[i];</span><br><span class="line"><span class="keyword">int</span> b = nums[i] * real_max[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">int</span> c = nums[i] * fake_max[i<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">real_max[i] = max(a, max(b, c));</span><br><span class="line"><span class="keyword">int</span> tmp = min(a, min(b, c));</span><br><span class="line"><span class="keyword">if</span> (tmp &lt; <span class="number">0</span>) fake_max[i] = tmp;</span><br><span class="line"><span class="keyword">else</span> fake_max[i] = real_max[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">ans = max(ans, real_max[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] real_max;</span><br><span class="line"><span class="keyword">delete</span>[] fake_max;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> # Leetcode 322. 零钱兑换 ## 题目描述 <em>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例 1: 输入: coins = [1, 2, 5], amount = 11 输出: 3 解释: 11 = 5 + 5 + 1 示例 2: 输入: coins = [2], amount = 3 输出: -1 说明: 你可以认为每种硬币的数量是无限的。</em> ## 解题思路 这道题跟[279. 完全平方数]如出一辙。 一开始用的是dfs+剪枝，结果超时了。然后换成动态规划，通过了。</p>
<h2 id="代码实现-7">代码实现</h2>
<h3 id="dfs剪枝-1">dfs+剪枝</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dfs+剪枝 超时</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> i, <span class="keyword">int</span> cur, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span> || k &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cout &lt;&lt; i &lt;&lt; " " &lt;&lt; cur &lt;&lt;   " k "&lt;&lt;k &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">if</span> (cur &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">ans = min(ans, cur);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cur++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">dfs(coins, j, cur, k-coins[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">sort(coins.begin(), coins.end());</span><br><span class="line">ans = <span class="number">999999</span>;</span><br><span class="line">dfs(coins, coins.size()<span class="number">-1</span>, <span class="number">0</span>, amount);</span><br><span class="line"><span class="keyword">if</span> (ans == <span class="number">999999</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划-1">动态规划</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> *dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">99999</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.size(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((i-coins[j]) &gt;= <span class="number">0</span> &amp;&amp; dp[i-coins[j]] != <span class="number">-1</span>) &#123;</span><br><span class="line">tmp = min(tmp, dp[i-coins[j]]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="number">99999</span>) dp[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> dp[i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = dp[amount];</span><br><span class="line"><span class="keyword">delete</span>[] dp;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-300.-最长上升子序列">Leetcode 300. 最长上升子序列</h1>
<h2 id="题目描述-7">题目描述</h2>
<p><em>给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例: 输入: [10,9,2,5,3,7,101,18] 输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(n2) 。 进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</em> ## 解题思路 用<span class="math inline">\(dp[i]\)</span>表示以<span class="math inline">\(nums[i]\)</span>结尾的上升子序列的长度。则状态转移方程如下： <span class="math display">\[
dp[i]=max\{1,1+d[j]\}
\]</span></p>
其中<span class="math inline">\(0\leq j&lt; i\)</span>。 这样的时间复杂度是<span class="math inline">\(O(n)\times O(n)=O(n^2)\)</span>。 要优化的话，应该是可以把<span class="math inline">\(j\)</span>的线性遍历变成二分查找。但具体我还没想好怎么弄。 ## 代码实现 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = nums.size();</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">dp[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">dp[i] = max(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] dp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> # Leetcode 5216. 统计元音字母序列的数目 ## 题目描述 <em>给你一个整数 n，请你帮忙统计一下我们可以按下述规则形成多少个长度为 n 的字符串： 字符串中的每个字符都应当是小写元音字母（'a', 'e', 'i', 'o', 'u'） 每个元音 'a' 后面都只能跟着 'e' 每个元音 'e' 后面只能跟着 'a' 或者是 'i' 每个元音 'i' 后面 不能 再跟着另一个 'i' 每个元音 'o' 后面只能跟着 'i' 或者是 'u' 每个元音 'u' 后面只能跟着 'a' 由于答案可能会很大，所以请你返回 模 10^9 + 7 之后的结果。 示例 1： 输入：n = 1 输出：5 解释：所有可能的字符串分别是：&quot;a&quot;, &quot;e&quot;, &quot;i&quot; , &quot;o&quot; 和 &quot;u&quot;。 示例 2： 输入：n = 2 输出：10 解释：所有可能的字符串分别是：&quot;ae&quot;, &quot;ea&quot;, &quot;ei&quot;, &quot;ia&quot;, &quot;ie&quot;, &quot;io&quot;, &quot;iu&quot;, &quot;oi&quot;, &quot;ou&quot; 和 &quot;ua&quot;。 示例 3： 输入：n = 5 输出：68 提示： 1 &lt;= n &lt;= 2 </em> 10^4* ## 解题思路 动态规划。用<span class="math inline">\(dp[i][0]\)</span>表示长度为<span class="math inline">\(i\)</span>且最后一个字符是<span class="math inline">\(a\)</span>的字符串数量；<span class="math inline">\(dp[i][1]\)</span>表示长度为<span class="math inline">\(i\)</span>且最后一个字符是<span class="math inline">\(e\)</span>的字符串数量；…… $$
<span class="math display">\[\begin{array}{clr}
dp[i][0]&amp;=dp[i-1][1]+dp[i-1][2]+dp[i-1][4]\\
dp[i][1]&amp;=d[i-1][0]+dp[i-1][2]\\

...&amp;=...
\end{array}\]</span>
<p>$$</p>
<h2 id="代码实现-8">代码实现</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countVowelPermutation</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> dp[<span class="number">20005</span>][<span class="number">5</span>];</span><br><span class="line">dp[<span class="number">1</span>][<span class="number">0</span>] = dp[<span class="number">1</span>][<span class="number">1</span>] = dp[<span class="number">1</span>][<span class="number">2</span>] = dp[<span class="number">1</span>][<span class="number">3</span>] = dp[<span class="number">1</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>] + dp[i<span class="number">-1</span>][<span class="number">2</span>] + dp[i<span class="number">-1</span>][<span class="number">4</span>];</span><br><span class="line">dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + dp[i<span class="number">-1</span>][<span class="number">2</span>];</span><br><span class="line">dp[i][<span class="number">2</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>] + dp[i<span class="number">-1</span>][<span class="number">3</span>];</span><br><span class="line">dp[i][<span class="number">3</span>] = dp[i<span class="number">-1</span>][<span class="number">2</span>];</span><br><span class="line">dp[i][<span class="number">4</span>] = dp[i<span class="number">-1</span>][<span class="number">2</span>] + dp[i<span class="number">-1</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">5</span>; k++) dp[i][k] %= <span class="number">1000000007</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (dp[n][<span class="number">0</span>] + dp[n][<span class="number">1</span>] + dp[n][<span class="number">2</span>] + dp[n][<span class="number">3</span>] + dp[n][<span class="number">4</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="柱状图中最大的矩形">84. 柱状图中最大的矩形</h1>
<h2 id="题目描述-8">题目描述</h2>
<p><em>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 示例: 输入: [2,1,5,6,2,3] 输出: 10</em> ## 解题思路 利用单调栈。单调栈是个非常有意思的工具，利用它可以完成许多看似复杂的事务。单调栈本身的工作流程可能很容易让人困惑，但其实它背后的思想是及其简单和巧妙的。看完这个推荐去看[85. 最大矩形]。 ### 从头开始分析 针对这个题，如下图，人会怎么思考呢？ <img data-src="/images/1570092653.859643.jpg" class="lazyload"> 我会先看最高的那个，也就是以6为高，能组成的最大矩形，结果是6；然后在再看次高的那个，也就是以5为高，能组成的最大矩形是10；然后看3，以此类推，知道最后一个，以1为高，能组成的最大的矩形为6。</p>
<h3 id="接下来">接下来</h3>
<p>试着从前往后遍历，先忽略前面的2，从1开始。首先遍历的是1 <img data-src="/images/1570092960.919559.jpg" class="lazyload"> 然后加入5 <img data-src="/images/1570093050.74308.jpg" class="lazyload"> 然后加入6 <img data-src="/images/1570093120.747516.jpg" class="lazyload"> 然后，重点来了，加入2。先不着急加入，从后往前，以6为高的矩形如下： <img data-src="/images/1570093251.246006.jpg" class="lazyload"> 以5为高的矩形如下： <img data-src="/images/1570093303.338743.jpg" class="lazyload"> 然后是1，1比2小，先不处理。把5和6拿出去，然后把2加入，如下： <img data-src="/images/1570093419.599918.jpg" class="lazyload"> 然后加入3 <img data-src="/images/1570093464.243223.jpg" class="lazyload"> 所有数组处理完毕。然后从后往前，以3为高的矩形： <img data-src="/images/1570093545.243242.jpg" class="lazyload"> 以2为高的矩形： <img data-src="/images/1570093602.465919.jpg" class="lazyload"> 以1为高的矩形： <img data-src="/images/1570093649.290845.jpg" class="lazyload"> 最大的就是以5为高的那个。 从上面的这个例子就基本能看出单调栈的工作流程了。</p>
<h2 id="代码实现-9">代码实现</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (heights.size() &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">heights.push_back(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">st.push(&#123;<span class="number">0</span>, heights[<span class="number">0</span>]&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; heights.size(); i++) &#123;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p = st.top();</span><br><span class="line"><span class="keyword">if</span> (heights[i] == p.second) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (heights[i] &gt; p.second) &#123;</span><br><span class="line">st.push(&#123;i, heights[i]&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (!st.empty() &amp;&amp; st.top().second &gt;= heights[i]) &#123;</span><br><span class="line">p = st.top();</span><br><span class="line">st.pop();</span><br><span class="line">ans = max(ans, p.second * ((i - <span class="number">1</span>) - p.first + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">st.push(&#123;p.first, heights[i]&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-85.-最大矩形">Leetcode 85. 最大矩形</h1>
<h2 id="题目描述-9">题目描述</h2>
<p><em>给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 示例: 输入: [ [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]] 输出: 6</em> ## 解题思路 利用上一题<a href="#柱状图中最大的矩形">84. 柱状图中最大的矩形</a>的思想和代码。把这个矩阵一行一行的累加起来，然后就可以用上上一题的代码了。<strong>注意</strong>，这个累加跟平常的累加有些许不同，注意看下面第四行。 第一行，也就是求<span class="math inline">\([1,0,1,0,0]\)</span>的柱状图中的最大矩形。 第二行，累加上第一行，也就是求<span class="math inline">\([2,0,2,1,1]\)</span>的最大矩形。 第三行，就是求<span class="math inline">\([3,1,3,2,2]\)</span>的最大矩形。 第四行，就是求<span class="math inline">\([4,0,0,3,0]\)</span>的最大矩形。</p>
<h2 id="代码实现-10">代码实现</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (heights.size() &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">heights.push_back(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">st.push(&#123;<span class="number">0</span>, heights[<span class="number">0</span>]&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; heights.size(); i++) &#123;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p = st.top();</span><br><span class="line"><span class="keyword">if</span> (heights[i] == p.second) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (heights[i] &gt; p.second) &#123;</span><br><span class="line">st.push(&#123;i, heights[i]&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (!st.empty() &amp;&amp; st.top().second &gt;= heights[i]) &#123;</span><br><span class="line">p = st.top();</span><br><span class="line">st.pop();</span><br><span class="line">ans = max(ans, p.second * ((i - <span class="number">1</span>) - p.first + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">st.push(&#123;p.first, heights[i]&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = matrix.size();</span><br><span class="line"><span class="keyword">if</span> (m &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; heights;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">heights.push_back(matrix[i][j] == <span class="string">'1'</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">heights[j] = matrix[i][j] == <span class="string">'1'</span> ? heights[j]+<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans, largestRectangleArea(heights));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="二维区域和检索---矩阵不可变">304. 二维区域和检索 - 矩阵不可变</h1>
<h2 id="题目描述-10">题目描述</h2>
<p><em>给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2)。 示例: 给定 matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]] sumRegion(2, 1, 4, 3) -&gt; 8 sumRegion(1, 1, 2, 2) -&gt; 11 sumRegion(1, 2, 2, 4) -&gt; 12 说明: 你可以假设矩阵不可变。 会多次调用 sumRegion 方法。 你可以假设 row1 ≤ row2 且 col1 ≤ col2。</em> ## 解题思路 树状数组。关于树状数组的有关说明可以看[220. 存在重复元素 III]，这里用到的是多维树状数组。 ### 核心代码 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; n; k += lowbit(k)) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> q = j; q &lt; n; q += lowbit(q)) &#123;</span><br><span class="line">c[k][q] += v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mySum</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &gt; <span class="number">0</span>; k -= lowbit(k)) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> q = j; q &gt; <span class="number">0</span>; q -= lowbit(q)) &#123;</span><br><span class="line">s += c[k][q];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 代码实现 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">1050</span>][<span class="number">1050</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">NumMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line"><span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">n = <span class="number">1050</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].size(); j++) &#123;</span><br><span class="line">add(i+<span class="number">1</span>, j+<span class="number">1</span>, matrix[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; n; k += lowbit(k)) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> q = j; q &lt; n; q += lowbit(q)) &#123;</span><br><span class="line">c[k][q] += v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mySum</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &gt; <span class="number">0</span>; k -= lowbit(k)) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> q = j; q &gt; <span class="number">0</span>; q -= lowbit(q)) &#123;</span><br><span class="line">s += c[k][q];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mySum(row2+<span class="number">1</span>, col2+<span class="number">1</span>) - mySum(row1, col2+<span class="number">1</span>) - mySum(row2+<span class="number">1</span>, col1) + mySum(row1, col1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">* NumMatrix* obj = new NumMatrix(matrix);</span></span><br><span class="line"><span class="comment">* int param_1 = obj-&gt;sumRegion(row1,col1,row2,col2);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure> # 220. 存在重复元素 III</p>
<h2 id="题目描述-11">题目描述</h2>
<p><em>给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。</em></p>
<p><em>来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/contains-duplicate-iii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</em> ## 树状数组 树状数组的通俗解释 树状数组本身是一个数组，只不过把它画成树的形式，为了更好理解接下来的操作。下面来结合图片进行说明。 首先假设有一个原始数组<span class="math inline">\(A\)</span>，<span class="math inline">\(A=[1,2,3,4,5,6,7,8]\)</span>。图下图所示。 <img data-src="/images/2.png" class="lazyload"> 然后，再申请一个数组<span class="math inline">\(C\)</span>，长度和<span class="math inline">\(A\)</span>相同，初始状态<span class="math inline">\(C\)</span>为空，即<span class="math inline">\(C=[0,0,0,0,0,0,0,0]\)</span>。如下图所示。 <img data-src="/images/3.png" class="lazyload"> 这个<span class="math inline">\(C\)</span>数组就是树状数组，可能现在还不不太清楚，怎么就树状数组了，别急，现在我们把<span class="math inline">\(C\)</span>数组在形式上稍微改变一下，再和<span class="math inline">\(A\)</span>数组对应起来，如下图所示。 <img data-src="/images/4.png" class="lazyload"> 现在在看，是不是<span class="math inline">\(C\)</span>数组就像是一个树了，帅气智。然后需要了解的就是这个<span class="math inline">\(C\)</span>数组究竟是用来干嘛的。还是看个例子。 $ C[1]=A[1]\ C[2]=C[1]+A[2]=A[1]+A[2]\ C[3]=A[3]=A[1]+A[2]+A[3]\ C[4]=C[2]+C[3]+A[4]=A[1]+A[2]+A[3]+A[4]\ C[5]=A[5]\ C[6]=C[5]+A[6]=A[5]+A[6]\ C[7]=A[7]\ C[8]=C[4]+C[6]+C[7]+A[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8]\ $ 这里直接给出计算<span class="math inline">\(C[i]\)</span>的公式，<span class="math inline">\(C[i]=sum\{A[j]|i-2^k+1\leq j \leq i\}\ (k是i的二进制表示中末尾0的个数)\)</span>。其实从上图也能看出来。我们把数字都标上，就变成了下图。 <img data-src="/images/1.png" class="lazyload"> 然后，需要知道的就要 这个数组数组可以用来做什么。它能做的事有两个：</p>
<ol type="1">
<li><span class="math inline">\(sum(i)\)</span>，计算<span class="math inline">\(A[1]+A[2]+...+A[i]\)</span>；</li>
<li><span class="math inline">\(add(i, x)\)</span>, 让<span class="math inline">\(A[i]\)</span>加上<span class="math inline">\(x\)</span>，然后更新更个树状数组。</li>
</ol>
<p>下面先说<span class="math inline">\(sum(i)\)</span>。 <span class="math inline">\(sum(i)=A[1]+A[2]+...+A[i]\\=A[1]+A[2]+A[i-2^k]+A[i-2^k+1]+...+A[i]\\=sum(i-2^k)+C[i]\\=sum(i-lowbit(i))+C[i]\)</span> 其中<span class="math inline">\(lowbit(i)\)</span>是用来计算<span class="math inline">\(2^k\)</span>的，其中<span class="math inline">\(k\)</span>是<span class="math inline">\(i\)</span>的二进制表示中末尾0的个数。 这里不解释了，直接上代码，用的就是<span class="math inline">\(lowbit(i)\)</span>这个函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是<span class="math inline">\(sum(i)\)</span>的代码实现： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span>; i -= lowbit(i)) &#123;</span><br><span class="line">s += c[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 说完<span class="math inline">\(sum(i)\)</span>再说<span class="math inline">\(add(i, x)\)</span>。<span class="math inline">\(add(i, x)\)</span>其实就是<span class="math inline">\(A[i]=A[i]+x\)</span>，其实就是看改变<span class="math inline">\(A[i]\)</span>的时候会改变那些<span class="math inline">\(C[j]\)</span>。跟<span class="math inline">\(sum(i)\)</span>很像，只不过是反着来。下面是代码。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= n; k += lowbit(k)) &#123;</span><br><span class="line">c[k] += x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 树状数组就先说这些，下面是树状数组的模版。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">20060</span>;</span><br><span class="line"><span class="keyword">int</span> c[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i)) &#123;</span><br><span class="line">c[i] += flag;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span>; i -= lowbit(i)) &#123;</span><br><span class="line">s += c[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="解题思路-1">解题思路</h2>
<p>构造一个长度为<span class="math inline">\(k\)</span>滑动窗口，然后利用树状数组查找这个滑动窗口中小于等于某个值的元素的个数。举个例子。 <em>输入: nums = [1,0,1,1], k = 1, t = 2 输出: true</em> 构造一个长度为1的滑动窗口，把0号加入到滑动窗口，此时滑动窗口为[1]，然后处理2号数字，也就是0。因为要满足<em>nums [i] 和 nums [j] 的差的绝对值最大为 t</em>，也即是<span class="math inline">\(|nums[j]-0|\leq t\)</span>,也就是<span class="math inline">\(-t+0\leq nums[j]\leq t+0\)</span>，也就是<span class="math inline">\(-2\leq nums[j]\leq 2\)</span>，然后树状数组登场，查找当前滑动窗口中小于等于<span class="math inline">\(t+0\)</span>的元素的个数，也就是小于等于2的元素的个数，[1]中小于等于2的元素有1个；然后查找当前滑动窗口中小于等于<span class="math inline">\((-t+0)-1\)</span>的元素的个数（想想为啥要再减1），也就是小于等于-3的元素的个数，[1]中小于等于-3的元素有0个；所以[1]中大于等于2并且小于等于2的元素有1个。又因为这是在当前滑动窗口里找的，所以可定符合 <em>i 和 j 之间的差的绝对值最大为 ķ</em>。 如果在处理j号元素时，没有找到符合条件的元素，也就是让滑动窗口右移一位，也即是把<span class="math inline">\(nums[j]\)</span>加入到滑动窗口，并把<span class="math inline">\(nums[j-k]\)</span>移除滑动窗口。代码就是 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(nums[j], <span class="number">1</span>); #表示滑动窗口中多了一个值为nums[j]的元素</span><br><span class="line">add(nums[j-k], <span class="number">-1</span>); #表示滑动窗口中少了一个值为nums[j-k]的元素</span><br></pre></td></tr></table></figure> 前提是<span class="math inline">\(j-k\geq 0\)</span>。 以上就是答题思路，然而在具体实践中，常遇到的两个问题是 1. 求左右边界时有可能超int范围，要用long类型 2. 对数组进行离散化处理。再利用一个数组a，关键代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">a[i] = nums[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(a, a+nums.size());#排序</span><br><span class="line">an = unique(a, a + nums.size()) - a; <span class="meta">#a的长度</span></span><br></pre></td></tr></table></figure> 在更新树状数组是，不再直接用<span class="math inline">\(nums[i]\)</span>，然是用<span class="math inline">\(nums[i]\)</span>在a数组中的下标。 ## 代码实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">20060</span>;</span><br><span class="line"><span class="keyword">int</span> c[n+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> a[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> an;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i)) &#123;</span><br><span class="line">c[i] += flag;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span>; i -= lowbit(i)) &#123;</span><br><span class="line">s += c[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">a[i] = nums[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(a, a+nums.size());</span><br><span class="line">an = unique(a, a + nums.size()) - a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.size(); j++) &#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> left = (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> )-t + (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> )nums[j]<span class="number">-1</span>, right = (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> )t + (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> )nums[j];</span><br><span class="line"><span class="keyword">int</span> idx_left = lower_bound(a, a+an, left) - a;</span><br><span class="line"><span class="keyword">int</span> idx_right = lower_bound(a, a+an, right) - a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a[idx_left] == left) idx_left++;</span><br><span class="line"><span class="keyword">if</span> (a[idx_right] == right) idx_right++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sum(idx_right) - sum(idx_left) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> idx_j = lower_bound(a, a+an, nums[j]) - a + <span class="number">1</span>;</span><br><span class="line">add(idx_j, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = j - k;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> idx_i = lower_bound(a, a+an, nums[i]) - a + <span class="number">1</span>;</span><br><span class="line">add(idx_i, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-5206.-删除字符串中的所有相邻重复项-ii">Leetcode 5206. 删除字符串中的所有相邻重复项 II</h1>
<h2 id="题目描述-12">题目描述</h2>
<p><em>给你一个字符串 s，「k 倍重复项删除操作」将会从 s 中选择 k 个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。 你需要对 s 重复进行无限次这样的删除操作，直到无法继续为止。 在执行完所有删除操作后，返回最终得到的字符串。 本题答案保证唯一。</em></p>
<p><em>实例1 输入：s = &quot;abcd&quot;, k = 2 输出：&quot;abcd&quot; 解释：没有要删除的内容。</em></p>
<p><em>实例2 输入：s = &quot;deeedbbcccbdaa&quot;, k = 3 输出：&quot;aa&quot; 解释： 先删除 &quot;eee&quot; 和 &quot;ccc&quot;，得到 &quot;ddbbbdaa&quot; 再删除 &quot;bbb&quot;，得到 &quot;dddaa&quot; 最后删除 &quot;ddd&quot;，得到 &quot;aa&quot;</em></p>
<p><em>实例3 输入：s = &quot;pbbcggttciiippooaais&quot;, k = 2 输出：&quot;ps&quot;</em></p>
<p><em>提示 1 &lt;= s.length &lt;= 10^5 2 &lt;= k &lt;= 10^4 s 中只含有小写英文字母。</em> ## 解题思路 刚看到这道题的时候没有什么思路，想这会不会要用到哪种我还不知道的数据结构或者奇妙的字符串算法，然后没有往下做就去吃饭去了。在去吃饭的路上，突发灵感——栈。这道题不就跟后缀表达式那种题目有异曲同工之妙吗。 ## 代码实现 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&gt; d;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (d.empty()) &#123;</span><br><span class="line">d.push_back(&#123;s[i], <span class="number">1</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (d.back().first == s[i]) &#123;</span><br><span class="line">d.back().second++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">d.push_back(&#123;s[i], <span class="number">1</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (d.back().second == k) &#123;</span><br><span class="line">d.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp; au : d) &#123;</span><br><span class="line"><span class="comment">// cout &lt;&lt; au.first &lt;&lt; " " &lt;&lt; au.second &lt;&lt; endl;</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">tmp</span><span class="params">(au.second, au.first)</span></span>;</span><br><span class="line">ans += tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> # Leetcode 5214. 最长定差子序列 ## 题目描述 <em>给你一个整数数组 arr 和一个整数 difference，请你找出 arr 中所有相邻元素之间的差等于给定 difference 的等差子序列，并返回其中最长的等差子序列的长度。 示例 1： 输入：arr = [1,2,3,4], difference = 1 输出：4 解释：最长的等差子序列是 [1,2,3,4]。</em> ## 解题思路 看到这个题目，第一个想到的就是刚刚做过的<a href="http://www.orangeash.cn/index.php/2019/10/05/leetcode-300-zuichangshangshengzixulie/" target="_blank" rel="noopener">最长上升子序列</a>。感觉就是稍微改一改就行了，然后提交发现，超时了。那么现在，就以这道<strong>最长定差子序列</strong>为例，说明一下我是如何进行优化的。 直接一点吧，本题的状态转移方程：</p>
<p><span class="math display">\[
dp[i]=\{1,dp[j]+1\}
\]</span></p>
<p>其中，<span class="math inline">\(0\leq j &lt; i\)</span>，并且还需要满足<span class="math inline">\(arr[i]-arr[j]=difference\)</span>。 怎么获得适合的<span class="math inline">\(j\)</span>呢？朴素的做法就是让<span class="math inline">\(j\)</span>在<span class="math inline">\([0,i-1]\)</span>这个区间，遍历就是了。这正是可以优化的地方。仔细想想我们真正需要的是什么，不就是单纯的一个满足<span class="math inline">\(arr[i]-arr[j]=difference\)</span>的<span class="math inline">\(j\)</span>吗，直接用一个<code>map&lt;int, int&gt;</code>来保存储存这些信息不就好了。这对应着代码里的<code>m[arr[i]] = i;</code>。 ## 代码实现 ### 超时 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestSubsequence</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> difference)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">100005</span>];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size(); i++) &#123;</span><br><span class="line">dp[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">if</span> ((arr[i] - arr[j]) == difference) &#123;</span><br><span class="line">dp[i] = max(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ### 通过 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestSubsequence</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> difference)</span> </span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">100005</span>];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">m[arr[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size(); i++) &#123;</span><br><span class="line">dp[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m.find(arr[i]-difference) != m.end()) &#123;</span><br><span class="line"><span class="keyword">int</span> j = m[arr[i]-difference];</span><br><span class="line">dp[i] = dp[j]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m[arr[i]] = i;</span><br><span class="line"></span><br><span class="line">ans = max(ans, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> # Leetcode 309. 最佳买卖股票时机含冷冻期</p>
<p><img data-src="/images/IMG_539D4F9DA04A-1.jpeg" class="lazyload"></p>
<h2 id="题目描述-13">题目描述</h2>
<p><em>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例: 输入: [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</em> ## 解题思路 依然是动态规划。 用<span class="math inline">\(dp[i]\)</span>表示到第<span class="math inline">\(i\)</span>为止，能赚到的最多的钱。状态转移方程为： <span class="math display">\[
dp[i]=
\left \{
\begin{array}{lr}
0&amp; i\leq 0\\
max\{dp[i-1], prices[i]-prices[j]+dp[j-2]\}&amp; otherwise
\end{array}
\right .
\]</span></p>
<p>说明：第<span class="math inline">\(i\)</span>天有两种情况，一是不买不卖，二是卖。不能是买。 如果是情况一，则<span class="math inline">\(dp[i]=dp[i-1]\)</span>; 如果是情况二，则<span class="math inline">\(dp[i]=max\{prices[i]-prices[j]+dp[j-2]\}\)</span>，其中<span class="math inline">\(0\leq j &lt; i\)</span>。因为如果第<span class="math inline">\(j\)</span>天买入，则第<span class="math inline">\(j-1\)</span>天是没法卖的，所以这里是<span class="math inline">\(dp[j-2]\)</span>。</p>
<h2 id="代码实现-11">代码实现</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (prices.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">5050</span>];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">if</span> (prices[i] - prices[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (j<span class="number">-2</span> &gt;= <span class="number">0</span>) tmp = dp[j<span class="number">-2</span>];</span><br><span class="line">dp[i] = max(dp[i],</span><br><span class="line">(prices[i]-prices[j]+tmp));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[prices.size()<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-1223.-掷骰子模拟">Leetcode 1223. 掷骰子模拟</h1>
<h2 id="题目描述-14">题目描述</h2>
<p><em>有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。 不过我们在使用它时有个约束，就是使得投掷骰子时，连续 掷出数字 i 的次数不能超过 rollMax[i]（i 从 1 开始编号）。 现在，给你一个整数数组 rollMax 和一个整数 n，请你来计算掷 n 次骰子可得到的不同点数序列的数量。 假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 模 10^9 + 7 之后的结果。 示例 1： 输入：n = 2, rollMax = [1,1,2,2,2,3] 输出：34 解释：我们掷 2 次骰子，如果没有约束的话，共有 6 </em> 6 = 36 种可能的组合。但是根据 rollMax 数组，数字 1 和 2 最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。因此，最终答案是 36-2 = 34。* ## 解题思路 设置一个<span class="math inline">\(f\)</span>矩阵，<span class="math inline">\(f[i][j]\)</span>表示以<span class="math inline">\(i\)</span>结尾长度为<span class="math inline">\(j\)</span>的串的个数，然后根据规则，迭代这个矩阵。 举着例子，假设第一次摇骰子，可能摇到1、2、3、4、5、6，所以就有<span class="math inline">\(f[1][1]=f[2][1]=f[3][1]=f[4][1]=f[5][1]=f[6][1]=1\)</span>，然后第二次摇骰子，假设上一次摇到的是1，这一次又摇到1，则<span class="math inline">\(f[1][2]=1\)</span>，如果这次摇到2，则<span class="math inline">\(f[2][1]=1\)</span>，就这么个意思。 ## 代码实现 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dieSimulator</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rollMax)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> mat[<span class="number">7</span>][<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> tmp[<span class="number">7</span>][<span class="number">16</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            mat[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        n--;</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmp));</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">15</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">6</span>; k++) &#123;</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span> (i == k) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (rollMax[i<span class="number">-1</span>] &gt; j) &#123;</span><br><span class="line">                                tmp[i][j+<span class="number">1</span>] = (tmp[i][j+<span class="number">1</span>] % <span class="number">1000000007</span> + mat[i][j] % <span class="number">1000000007</span>) % <span class="number">1000000007</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            tmp[k][<span class="number">1</span>] = (tmp[k][<span class="number">1</span>] % <span class="number">1000000007</span> + mat[i][j] % <span class="number">1000000007</span>) % <span class="number">1000000007</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">15</span>; j++) &#123;</span><br><span class="line">                    mat[i][j] = tmp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">15</span>; j++) &#123;</span><br><span class="line">                ans += (mat[i][j] % <span class="number">1000000007</span>);</span><br><span class="line">                ans %= <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="leetcode-401.-二进制手表">Leetcode 401. 二进制手表</h1>
<h2 id="题目描述-15">题目描述</h2>
<p><em>二进制手表顶部有 4 个 LED 代表小时（0-11），底部的 6 个 LED 代表分钟（0-59）。 每个 LED 代表一个 0 或 1，最低位在右侧。 例如，上面的二进制手表读取 “3:25”。 给定一个非负整数 n 代表当前 LED 亮着的数量，返回所有可能的时间。 案例: 输入: n = 1 返回: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;] 注意事项: 输出的顺序没有要求。 小时不会以零开头，比如 “01:00” 是不允许的，应为 “1:00”。 分钟必须由两位数组成，可能会以零开头，比如 “10:2” 是无效的，应为 “10:02”。</em> ## 解题思路 重要的是遍历搜索所有可能的亮灯方案，dfs就可以。 ## 代码实现 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">trans</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="built_in">string</span> tmp = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (k != <span class="number">0</span>) &#123;</span><br><span class="line">            tmp += <span class="built_in">string</span>(<span class="number">1</span>, <span class="string">'0'</span> + (k % <span class="number">10</span>));</span><br><span class="line">            k /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> t = s[i];</span><br><span class="line">            s[i] = s[len<span class="number">-1</span>-i];</span><br><span class="line">            s[len<span class="number">-1</span>-i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// for (int j = 0; j &lt; n; j++) &#123;</span></span><br><span class="line">                <span class="comment">//     cout &lt;&lt; a[j] &lt;&lt; " ";</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> hour = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> sec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                    hour += (<span class="keyword">int</span>(<span class="built_in">pow</span>(<span class="number">2</span>, j)) * a[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">4</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    sec += (<span class="keyword">int</span>(<span class="built_in">pow</span>(<span class="number">2</span>, j<span class="number">-4</span>)) * a[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (hour &lt; <span class="number">12</span> &amp;&amp; sec &lt; <span class="number">60</span>) &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">string</span> h = trans(hour);</span><br><span class="line">                    <span class="built_in">string</span> s = trans(sec);</span><br><span class="line">                    <span class="keyword">if</span> (s.length() == <span class="number">1</span>) s += <span class="string">"0"</span>;</span><br><span class="line">                    </span><br><span class="line">                    rotate(h);</span><br><span class="line">                    rotate(s);</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">string</span> tmp = h + <span class="string">":"</span> + s;</span><br><span class="line">                    ans.push_back(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            a[i] = <span class="number">0</span>;</span><br><span class="line">            dfs(i+<span class="number">1</span>, k);</span><br><span class="line">            a[i] = <span class="number">1</span>;</span><br><span class="line">            dfs(i+<span class="number">1</span>, k<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; readBinaryWatch(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        n = <span class="number">10</span>;</span><br><span class="line">        dfs(<span class="number">0</span>, num);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Ash's Blogs</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/12/01/leecode%E9%A2%98%E7%9B%AE/">http://yoursite.com/2019/12/01/leecode%E9%A2%98%E7%9B%AE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Hexo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/12/04/%E6%97%A5%E5%B8%B8/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>日常</span></div></a></div><div class="next-post pull_right"><a href="/2019/11/24/word2vec%E7%BB%83%E4%B9%A0/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>word2vec练习</span></div></a></div></nav></div></div><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;Mon Nov 18 2019 08:00:00 GMT+0800 (GMT+08:00) - 2019 By Ash's Blogs</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>