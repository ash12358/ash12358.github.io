{"meta":{"title":"Hexo","subtitle":"","description":"Ash的博客","author":"Ash's Blogs","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"LeetCode题目","slug":"leecode题目","date":"2019-11-30T16:00:00.000Z","updated":"2019-12-02T12:39:56.393Z","comments":true,"path":"2019/12/01/leecode题目/","link":"","permalink":"http://yoursite.com/2019/12/01/leecode%E9%A2%98%E7%9B%AE/","excerpt":"","text":"139. 单词拆分 1.题目描述 给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： 拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。 示例 1： 输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;] 输出: true 解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。 ## 2.解题思路 这道题跟前面的[解码方法]一题非常非常地像。用\\(dp[i][j]\\)表示字符串\\(s[i:j]\\)是否可拆分，是为1，否为0。状态转移方程如下： \\[ dp[i]=\\left \\{ \\begin{array}{cl} 1 &amp;i&gt;j\\\\ dp[i][j-k-1]\\ and\\ s[j-k:j]\\ in\\ wordDict&amp;i\\neq j \\end{array} \\right . \\] 其中\\(0\\leq k\\leq j-i\\)。 然后我发现，这道题都用不着\\(i\\)，直接用\\(dp[j]\\)表示字符串\\(s[0:j]\\)是否可拆分，所以公式改为： \\[ dp[j]=\\begin{cases}1&amp; i&gt;j\\\\ dp[j-k-1]\\ and\\ s[j-k:j]\\ in\\ wordDict &amp; otherwise\\end{cases} \\] 其中\\(0\\leq k\\leq j\\)。 ## 3.代码实现 ### 3.1记忆化搜索 方便理解 12345678910111213141516171819class Solution &#123;public:int dp[1050];int getDp(int j, string&amp; s, vector&lt;string&gt;&amp; wordDict) &#123;if (0 &gt; j) return 1;if (dp[j] != -1) return dp[j];for (int k = 0; k &lt;= j; k++) &#123;int tmp = find(wordDict.begin(), wordDict.end(), s.substr(j-k, k+1)) != wordDict.end();if (getDp(j-k-1, s, wordDict) &amp;&amp; tmp) return dp[j] = 1;&#125;return dp[j] = 0;&#125;bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;memset(dp, -1, sizeof(dp));return getDp(s.length()-1, s, wordDict);&#125;&#125;; ### 3.2动态规划 12345678910111213141516171819class Solution &#123;public:bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;int dp[1050];for (int j = 0; j &lt; s.length(); j++) &#123;for (int k = 0; k &lt;= j; k++) &#123;int tmp = find(wordDict.begin(), wordDict.end(), s.substr(j-k, k+1)) != wordDict.end();if (j-k-1 &lt; 0) &#123;dp[j] = tmp;&#125;else &#123;dp[j] = dp[j-k-1] &amp;&amp; tmp;if (dp[j] == 1) break;&#125;&#125;&#125;return dp[s.length()-1];&#125;&#125;; # 279. 完全平方数 ## 题目描述 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例 1: 输入: n = 12 输出: 3 解释: 12 = 4 + 4 + 4. 示例 2: 输入: n = 13 输出: 2 解释: 13 = 4 + 9. ## 解题思路 ### 动态规划 用\\(dp[i]\\)表示组成\\(i\\)需要的完全平方数的最少个数。状态转移方程是： \\[ dp[i]= \\left \\{ \\begin{array}{lr} \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ 0\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ i=0\\\\ min\\{dp[i-j^2]+1\\ |\\ i-j^2\\geq 0\\}\\ \\ \\ \\ i\\neq0 \\end{array} \\right . \\] 其中\\(j=[1,2,3...]\\)。 ### dfs+剪枝 dfs就比较好理解了。 123void dfs(int T, int cur) &#123; //目标是T，当前深度为cur...&#125; 搜索过程如下： 代码实现 动态规划 1234567891011121314151617181920class Solution &#123;public:int *dp;int numSquares(int n) &#123;dp = new int[n+1];for (int i = 0; i &lt;= n; i++) &#123;int m = i;for (int k = 1; i-k*k&gt;=0; k++) &#123;m = min(m, dp[i-k*k]+1);&#125;dp[i] = m;&#125;int ans = dp[n];delete[] dp;return ans;&#125;&#125;; dfs+剪枝 1234567891011121314151617181920class Solution &#123;public:int ans;void dfs(int T, int cur) &#123;if (T &lt; 0 || cur &gt;= ans) return;if (T == 0) &#123;ans = cur;return;&#125;int k = int(sqrt(T));for (; k &gt;=1; k--) &#123;dfs(T-k*k, cur+1);&#125;&#125;int numSquares(int n) &#123;ans = 9999999;dfs(n, 0);return ans;&#125;&#125;; 5. 最长回文子串 解题思路 定义： \\[ dp[i][j]= \\begin{cases} 0,s[i,j]不是回文串\\\\ 1,s[i,j]是回文串 \\end{cases} \\] 状态转移方程： \\[ dp[i][j]= \\begin{cases} dp[i+1][j-1],s[i]=s[j]\\\\ dp[i+1][j]\\ or\\ dp[i][j-1],s[i]\\neq s[j] \\end{cases} \\] 举个例子：输入: &quot;babad&quot; 输出: &quot;bab&quot; 注意: &quot;aba&quot; 也是一个有效答案。 初始化\\(dp[i][j]=1\\ (i&gt;=j)\\)，因为空串或者长度为1的字符串肯定是回文串。 也就是下图这样： 然后在看那个状态转移方程，搞明白要求一个\\(dp[i][j]\\)需要用到的的是那些元素。如下图： 可以看出，要求\\(dp[i][j]\\)，需要知道跟他它紧挨着的左下角的三个元素，而我们最终要求的是整个串的最长回文串，所以需要求到\\(dp[0][s.length-1]\\)。也就是下面蓝色星星这个位置： 说到现在，整个状态转移的过程就差不多明了了： 就这么斜着，一层一层地，直到到达最右上角的位置。 上面例子的最后状态就是： 下一步就是怎么把回文串弄出来，方法是回溯，从离右上角最近的1开始，往对角线的方向走，如果其左下角为1，则直接移动到左下角，如果为0，则考虑往右或者往下走。经过的路径就是回文串的一半。 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123;public:string longestPalindrome(string s) &#123;if (s.length() == 0) &#123;return \"\";&#125;int dp[1050][1050] = &#123;0&#125;;for (int i = 0; i &lt; s.length(); i++) &#123; // 初始化for (int j = 0; j &lt; s.length(); j++)dp[i][j] = 1;&#125;int last_i=0, last_j=0;// 下面开始一步一步地逼近dp[0][s.length()-1]for (int k = 1; k &lt; s.length(); k++) &#123;for (int i = 0; i &lt; s.length()-k; i++) &#123;int j = i + k;if (s[i] == s[j])dp[i][j] = dp[i+1][j-1];elsedp[i][j] = 0;if (dp[i][j] == 1) &#123; //记下最后一个是回文串的位置，方便回溯last_i = i;last_j = j;&#125;&#125;&#125;int i = last_i, j = last_j;string ans = \"\";while (i &lt; j) &#123;if (dp[i+1][j-1] == dp[i+1][j-1]) &#123;ans += s[i];i++;j--;&#125;else if (dp[i][j-1] == dp[i][j]) &#123;j--;&#125;else if (dp[i+1][j] == dp[i][j]) &#123;i++;&#125;&#125;string t = ans;if (i == j) ans += s[i];for (int k = t.length()-1; k &gt;= 0; k--) ans += t[k];return ans;&#125;&#125;; 263. 丑数 I 题目描述 编写一个程序判断给定的数是否为丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例 1: 输入: 6 输出: true 解释: 6 = 2 × 3 ## 代码实现 12345678910class Solution &#123;public:bool isUgly(int num) &#123;if (num == 0) return false;while (num % 5 == 0) num /= 5;while (num % 3 == 0) num /= 3;while (num % 2 == 0) num /= 2;return num == 1;&#125;&#125;; # 264. 丑数 II ## 题目描述 编写一个程序，找出第 n 个丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例: 输入: n = 10 输出: 12 解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明: 1 是丑数。 n 不超过1690。 ## 代码实现 1234567891011121314151617class Solution &#123;public:int nthUglyNumber(int n) &#123;int dp[2000];dp[0] = 1;int l2 = 0;int l3 = 0;int l5 = 0;for (int i = 1; i &lt; n; i++) &#123;dp[i] = min(dp[l2]*2, min(dp[l3]*3, dp[l5]*5));while (dp[l2]*2 &lt;= dp[i]) l2++;while (dp[l3]*3 &lt;= dp[i]) l3++;while (dp[l5]*5 &lt;= dp[i]) l5++;&#125;return dp[n-1];&#125;&#125;; # Leetcode 198. 打家劫舍 I/II 1.打家劫舍I 1.1题目描述 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 输入: [1,2,3,1] 输出: 4 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 ### 1.2解题思路 妥妥的动态规划。用\\(dp[i][0]\\)表示在\\(0\\)到\\(i\\)号屋子中，不抢劫第\\(i\\)号屋子所能获得的最大现金；\\(dp[i][i]\\)表示在\\(0\\)到\\(i\\)号屋子中，抢劫第\\(i\\)号屋子所能获得的最大现金。则状态转移方程如下： \\[ \\begin{array}{lr} dp[i][0]= \\left \\{ \\begin{array}{lr} \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ 0\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ i=0\\\\ max\\{dp[i-1][0],dp[i-1][1]\\}\\ \\ \\ \\ i\\neq0 \\end{array} \\right .\\\\ ~\\\\ dp[i][1]= \\left \\{ \\begin{array}{lr} \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ nums[i]\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ i=0\\\\ dp[i-1][0]+nums[i]\\ \\ \\ \\ i\\neq0 \\end{array} \\right . \\end{array} \\] 稍微说明一下，假如第\\(i\\)间房屋不抢，则第\\(i-1\\)间房屋可以抢也可以不抢，对应着公式$dp[i][0]=max\\{dp[i-1][0],dp[i-1][1]\\}$；假如第\\(i\\)间房屋要抢，则第\\(i-1\\)间房屋必然不能抢，对应着公式$dp[i][1]=dp[i-1][0]+nums[i]$； ### 1.3代码实现 12345678910111213141516171819202122class Solution &#123;public:int dp[9999][2];int rob(vector&lt;int&gt;&amp; nums) &#123;if (nums.size() == 0) &#123;return 0;&#125;memset(dp, 0, sizeof(dp));for (int i = 0; i &lt; nums.size(); i++) &#123;if (i == 0) &#123;dp[i][0] = 0;dp[i][1] = nums[i];&#125;else &#123;dp[i][0] = max(dp[i-1][0], dp[i-1][1]);dp[i][1] = dp[i-1][0] + nums[i];&#125;&#125;return max(dp[nums.size()-1][0], dp[nums.size()-1][1]);&#125;&#125;; ## 2.打家劫舍II ### 2.1题目描述 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 输入: [2,3,2] 输出: 3 解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 ### 2.2解题思路 跟第一道题相比，不同之处就在第一间和最后一间房屋变成相邻的了。所以这里就有了四种情况： 1. 第一间和最后一间都不抢 2. 抢第一间，不抢最后一间 3. 不抢第一间，抢最后一间 4. 都抢 前三种情况完成可以用第一题的代码去解决。主要是第四种情况有点不一样。因为现在第一间跟最后一间变成相邻的了，所有现在需要从其二者中选择去掉一个。那么这个问题就分成了两个问题： 1) 从第一间房到倒数第二间房所能获得到最大现金 2) 从第二间房到最后一间房所能获得到最大现金 2.3代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public:int dp[9999][2];int rob1(vector&lt;int&gt;&amp; nums) &#123;if (nums.size() == 0) &#123;return 0;&#125;memset(dp, 0, sizeof(dp));for (int i = 0; i &lt; nums.size(); i++) &#123;if (i == 0) &#123;dp[i][0] = 0;dp[i][1] = nums[i];&#125;else &#123;dp[i][0] = max(dp[i-1][0], dp[i-1][1]);dp[i][1] = dp[i-1][0] + nums[i];&#125;&#125;return max(dp[nums.size()-1][0], dp[nums.size()-1][1]);&#125;int rob(vector&lt;int&gt;&amp; nums) &#123;if (nums.size() == 0) &#123;return 0;&#125;int ans = rob1(nums);if (ans == dp[nums.size()-1][0]) &#123;return ans;&#125;else &#123;if (nums.size() &lt;=1) return ans;int last = nums[nums.size()-1];nums.pop_back();int ans1 = rob1(nums);nums.push_back(last);nums.erase(nums.begin());int ans2 = rob1(nums);return max(ans1, ans2);&#125;&#125;&#125;; 5208. 穿过迷宫的最少移动次数 题目描述 ## 思想 想法很简单，就是用BFS一层一层的搜索就可以。但针对这个问题，有些地方需要改变下。 ### 首先是当前位置 以前在一个二维地图上进行BFS，当前位置都是用\\((i,j)\\)这样一个坐标表示的，但现在这条小蛇独占了2个格子，也就是需要用两个坐标来表示，即\\((i_1,j_1),(i_2,j_2)\\)，约定第一个坐标表示蛇的尾部，第二个坐标表示蛇的头部。为了方便实现，我们定义一个结构体： 12345struct Node &#123;int a, b, c, d;Node() &#123;&#125;Node(int _a, int _b, int _c, int _d) : a(_a), b(_b), c(_c), d(_d) &#123;&#125;&#125;; 其中(a,b)对应着\\((i_1,j_1)\\)，同理，(c,d)对应着\\((i_2,j_2)\\)。 ### 然后是记录已经访问过的“小蛇的位置” 以前都是用visited[i][j]来表示\\((i,j)\\)有没有被访问过，而在这里，我定义了一个集合: 1set&lt;Node&gt; visited; ### 再有就是“如何走” 从某个位置可以走的方案一共四种，分别是： 1234Node try_right = Node(p.a, p.b+1, p.c, p.d+1);Node try_down = Node(p.a+1, p.b, p.c+1, p.d);Node try_clockwise = Node(p.a, p.b, p.a+1, p.b);Node try_anti = Node(p.a, p.b, p.a, p.b+1); ## 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879struct Node &#123;int a, b, c, d;Node() &#123;&#125;Node(int _a, int _b, int _c, int _d) : a(_a), b(_b), c(_c), d(_d) &#123;&#125;bool operator &lt; (const Node &amp;n) const &#123;if (a != n.a) return a &lt; n.a;if (b != n.b) return b &lt; n.b;if (c != n.c) return c &lt; n.c;if (d != n.d) return d &lt; n.d;return false;&#125;&#125;;class Solution &#123;public:int minimumMoves(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;Node start = Node(0, 0, 0, 1);set&lt;Node&gt; visited;visited.insert(start);deque&lt;Node&gt; d;d.push_back(start);int m = grid.size(), n = grid[0].size();int ans = 0;while (!d.empty()) &#123;int len = d.size();for (int i = 0 ; i &lt; len; i++) &#123;Node &amp;p = d.front();if (p.a == (m-1) &amp;&amp; p.c == (m-1) &amp;&amp; p.b == (n-2) &amp;&amp; p.d == (n-1)) &#123;return ans;&#125;Node try_right = Node(p.a, p.b+1, p.c, p.d+1);Node try_down = Node(p.a+1, p.b, p.c+1, p.d);Node try_clockwise = Node(p.a, p.b, p.a+1, p.b);Node try_anti = Node(p.a, p.b, p.a, p.b+1);if (p.a == p.c) &#123; //小蛇是横着的if (try_right.d &lt; n &amp;&amp; grid[try_right.c][try_right.d] != 1 &amp;&amp; visited.find(try_right) == visited.end()) &#123;visited.insert(try_right);d.push_back(try_right);&#125;if (try_down.a &lt; m &amp;&amp; grid[try_down.a][try_down.b] != 1 &amp;&amp; grid[try_down.c][try_down.d] != 1) &#123;if (visited.find(try_down) == visited.end()) &#123;visited.insert(try_down);d.push_back(try_down);&#125;if (visited.find(try_clockwise) == visited.end()) &#123;visited.insert(try_clockwise);d.push_back(try_clockwise);&#125;&#125;&#125;else &#123; //小蛇是竖着的if (try_down.c &lt; m &amp;&amp; grid[try_down.c][try_down.d] != 1 &amp;&amp; visited.find(try_down) == visited.end()) &#123;visited.insert(try_down);d.push_back(try_down);&#125;if (try_right.b &lt; n &amp;&amp; grid[try_right.a][try_right.b] != 1 &amp;&amp; grid[try_right.c][try_right.d] != 1) &#123;if (visited.find(try_right) == visited.end()) &#123;visited.insert(try_right);d.push_back(try_right);&#125;if (visited.find(try_anti) == visited.end()) &#123;visited.insert(try_anti);d.push_back(try_anti);&#125;&#125;&#125;d.pop_front();&#125;ans++;&#125;return -1;&#125;&#125;; # Leetcode 5099. 验证回文字符串 III ## 题目描述 给出一个字符串 s 和一个整数 k，请你帮忙判断这个字符串是不是一个「K 回文」。 所谓「K 回文」：如果可以通过从字符串中删去最多 k 个字符将其转换为回文，那么这个字符串就是一个「K 回文」。 示例： 输入：s = &quot;abcdeca&quot;, k = 2 输出：true 解释：删除字符 “b” 和 “e”。 提示： 1 &lt;= s.length &lt;= 1000 s 中只含有小写英文字母 1 &lt;= k &lt;= s.length ## 解题思路 动态规划。 一开始是想着用记忆搜索那种方法，但是内存超限，然后用动态规划，时间超限。。。最后灵机一动，巧妙一变，问题引刃而解。 用\\(dp[i][j]\\)表示将字符串\\(s[i:j]\\)变成回文需要的最少操作数。状态转移方程如下： \\[ dp[i][j]= \\left \\{ \\begin{array}{clr} 0&amp; i\\geq j\\\\ dp[i+1][j-1]&amp; i &lt; j,s[i]=s[j]\\\\ min\\{dp[i+1][j],dp[i][j-1]\\}&amp; i &lt; j,s[i]\\neq s[j] \\end{array} \\right . \\] 这样就把k巧妙的去掉了，好理解，公式简洁，代码简单。 至于动态转移方程的具体过程讲解，请看5. 最长回文子串，二者非常非常地像。 代码实现 12345678910111213141516171819202122class Solution &#123;public:bool isValidPalindrome(string s, int k) &#123;int dp[1050][1050];int n = s.length();memset(dp, 0, sizeof(dp));for (int k = 1; k &lt; n; k++) &#123;for (int i = 0; i &lt;= n-1-k; i++) &#123;int j = i+k;if (s[i] == s[j]) &#123;dp[i][j] = dp[i+1][j-1];&#125;else &#123;dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1;&#125;&#125;&#125;return dp[0][n-1] &lt;= k;&#125;&#125;; Leetcode 120. 三角形最小路径和 题目描述 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形： [ [2], [3,4], [6,5,7], [4,1,8,3]] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 ## 解题思路 动态规划，用\\(dp[i][j]\\)表示从顶点到达\\((i, j)\\)点的最短路径和。状态转移方程如下： \\[ dp[i][j]= \\left \\{ \\begin{array}{clr} triangle[i][j]&amp; i=0\\\\ triangle[i][j]+dp[i-1][j]&amp; j=0\\\\ triangle[i][j]+dp[i-1][j-1]&amp; j=triangle[i].length-1\\\\ triangle[i][j]+min\\{dp[i-1][j],dp[i-1][j-1]\\}&amp; 0 &lt; j &lt; triangle[i].length-1 \\end{array} \\right . \\] 可以看出来，更新第\\(i\\)行只需要用到第\\(i-1\\)行，所以可以进一步优化空间。 用\\(dp[j]\\)表示从顶点到达\\((i, j)\\)点的最短路径和,优化之后的公式如下： \\[ dp[j]= \\left \\{ \\begin{array}{clr} triangle[i][j]&amp; i=0\\\\ triangle[i][j]+dp[j]&amp; j=0\\\\ triangle[i][j]+dp[j-1]&amp; j=triangle[i].length-1\\\\ triangle[i][j]+min\\{dp[j],dp[j-1]\\}&amp; 0 &lt; j &lt; triangle[i].length-1 \\end{array} \\right . \\] 其中，\\(i=\\{0,1,2,...,n-1\\}\\) \\(j=\\{triangle[i].length-1, triangle[i].length-2,...,0\\}\\) 注意，\\(j\\)必须是降序，这是因为求\\(dp[j]\\)需要用到\\(dp[j-1]\\)。如果求\\(dp[j]\\)需要用到\\(dp[j+1]\\)，则\\(j\\)需要是升序。 代码实现 不带空间优化 123456789101112131415161718192021222324252627282930class Solution &#123;public:int minimumTotal(vector &lt; vector &lt; int &gt; &gt; &amp; triangle) &#123;int dp[1050][1050] = &#123;0&#125;;int n = triangle.size();if (n == 0) return 0;if (triangle[0].size() == 0) return 0;dp[0][0] = triangle[0][0];for (int i = 1; i &lt; n; i++) &#123;for (int j = 0; j &lt; triangle[i].size(); j++) &#123;if (j == 0) &#123;dp[i][j] = dp[i-1][j] + triangle[i][j];&#125;else if (j == triangle[i].size()-1) &#123;dp[i][j] = dp[i-1][j-1] + triangle[i][j];&#125;else &#123;dp[i][j] = triangle[i][j] + min(dp[i-1][j], dp[i-1][j-1]);&#125;&#125;&#125;int ans = dp[n-1][0];for (int j = 1; j &lt; triangle[n-1].size(); j++) &#123;ans = min(ans, dp[n-1][j]);&#125;return ans;&#125;&#125;; 空间优化 123456789101112131415161718192021222324252627282930class Solution &#123;public:int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123;int dp[1050] = &#123;0&#125;;int n = triangle.size();if (n == 0) return 0;if (triangle[0].size() == 0) return 0;dp[0] = triangle[0][0];for (int i = 1; i &lt; n; i++) &#123;for (int j = triangle[i].size()-1; j &gt;= 0; j--) &#123;if (j == 0) &#123;dp[j] = dp[j] + triangle[i][j];&#125;else if (j == triangle[i].size()-1) &#123;dp[j] = dp[j-1] + triangle[i][j];&#125;else &#123;dp[j] = triangle[i][j] + min(dp[j], dp[j-1]);&#125;&#125;&#125;int ans = dp[0];for (int j = 1; j &lt; triangle[n-1].size(); j++) &#123;ans = min(ans, dp[j]);&#125;return ans;&#125;&#125;; Leetcode 435. 无重叠区间 题目描述 给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。 注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 示例 1: 输入: [ [1,2], [2,3], [3,4], [1,3] ] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 ## 解题思路 贪心思想。这种遇见的问题，首先按照端点或者区间长度排个序往往能起到事半功倍的效果。 官方题解里有详细解题说明。 ## 代码实现 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public:static bool cmp(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b) &#123;return a[0] &lt;= b[0];&#125;bool judge(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b) &#123;return !(a[1] &lt;= b[0] || b[1] &lt;= a[0]);&#125;int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;if (intervals.size() &lt;= 0) return 0;sort(intervals.begin(), intervals.end(), cmp);// for (auto &amp;au : intervals) &#123;// cout &lt;&lt; au[0] &lt;&lt; \" \" &lt;&lt; au[1] &lt;&lt; endl;// &#125;int ans = 0;int pre = 0;for (int i = 1; i &lt; intervals.size(); i++) &#123;if (judge(intervals[pre], intervals[i])) &#123;if (intervals[pre][0] &lt;= intervals[i][0] &amp;&amp; intervals[pre][1] &gt;= intervals[i][1]) &#123;pre = i;ans += 1;&#125;else &#123;ans += 1;&#125;&#125;else &#123;pre = i;&#125;&#125;return ans;&#125;&#125;; # 542. 01 矩阵 ## 题目描述 给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。 两个相邻元素间的距离为 1 。 注意： 1. 给定矩阵的元素个数不超过 10000。 2. 给定矩阵中至少有一个元素是 0。 3. 矩阵中的元素只在四个方向上相邻: 上、下、左、右。 ### 一开始想的是 一开始想的是BFS，遍历数组，如果当前元素是1，则从当前位置开始BFS，这样的话，遍历数组用时\\(O(n^2)\\)，BFS用时\\(O(n^2)\\)，总体时间复杂度为\\(O(n^4)\\)，感觉不太行。 ### 动态规划？ 突然起了个想法，也可能是前两天写的两篇博客都是关于动态规划的，就想着这个能不能用动态规划做呢？然后就想出了下面的东西（其实我不确定这是不是对的）。 用\\(dp[i][j]\\)表示位于\\((i,j)\\)的1到最近的 0 的距离。看一下下面的图： 要求\\(dp[i][j]\\)不就需要求它周围的这8个点的\\(dp\\)值，再加上1或者2不就好了吗。公式如下： \\[ dp[i][j]=min \\left \\{ \\begin{array}{lr} dp[i-1][j-1]+2,\\\\ dp[i-1][j]+1,\\\\ dp[i-1][j+1]+2,\\\\ dp[i][j-1]+1,\\\\ dp[i][j+1]+1,\\\\ dp[i+1][j-1]+2,\\\\ dp[i+1][j]+1,\\\\ dp[i+1][j+1]+2 \\end{array} \\right . \\] 然后我发现这样还不够简单，再改改，去掉四个角点： 然后公式就变成了： \\[ dp[i][j]=min \\left \\{ \\begin{array}{lr} dp[i-1][j],\\\\ dp[i][j-1],\\\\ dp[i][j+1],\\\\ dp[i+1][j],\\\\ \\end{array} \\right \\}+1 \\] 然后我又在想，初始状态是怎么弄呢？因为这个转移方程形式是从四周向着一个中心点收缩，所有有些点是一开始就应该被初始化，这些点就是\\(matrix[i][j]=0\\)的点。 也即是首先把所有\\(matrix[i][j]=0\\)的点的\\(dp\\)值设为0，然后从以这些点为基础“广播”，如下图： 上图中，蓝色的是初始\\(dp\\)为0的点，紫色圈是不断进行状态转移，数字表示“广播”的距离。哎呦，这不就是BFS吗！？ ### 回到BFS 一开始想到BFS是以\\(matrix[i][j]=1\\)的位置为起始位置进行BFS，不妨换一种思路：以\\(matrix[i][j]=0\\)的位置为起始位置进行BFS，当遇到\\(matrix[i][j]=1\\)的位置时，那么其\\(dp\\)值就是BFS的层数。问题被巧妙地解决了。时间复杂度为\\(O(n^2)\\)。 ### 小技巧 题目中告诉我们给定矩阵的元素个数不超过 10000，如果设置一个数组int visited[10000][10000]，这样内存不够用的，技巧是设置一个int visited[10000]，然后将位置\\((i,j)\\)离散化处理，变成\\(i*n+j\\)，其中\\(n\\)是\\(matrix\\)的列数。这样原来的visited[i][j]=1就变成了visited[i*n+j]=1。 ## 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public:vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;int next[4][2] = &#123;&#123;-1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;1, 0&#125;&#125;;vector&lt;vector&lt;int&gt;&gt; ans = matrix;int visited[10002] = &#123;0&#125;;deque&lt;pair&lt;int, int&gt;&gt; d;int m = matrix.size(), n = matrix[0].size();;for (int i = 0; i &lt; m; i++) &#123;for (int j = 0; j &lt; n; j++) &#123;if (matrix[i][j] == 0) &#123;d.push_back(make_pair(i, j));visited[i*n+j] = 1;&#125;&#125;&#125;int step = 0;while (!d.empty()) &#123;int len = d.size();for (int k = 0; k &lt; len; k++) &#123;pair&lt;int, int&gt; p = d.front();d.pop_front();int i = p.first, j = p.second;if (matrix[i][j] == 1) &#123;ans[i][j] = step;&#125;for (int t = 0; t &lt; 4; t++) &#123;int next_i = i+ next[t][0], next_j = j + next[t][1];if (!(next_i &lt; 0 || next_i &gt;= matrix.size() || next_j &lt; 0 || next_j &gt;= matrix[0].size() || visited[next_i*n+next_j] == 1)) &#123;d.push_back(make_pair(next_i, next_j));visited[next_i*n+next_j] = 1;&#125;&#125;&#125;step++;&#125;return ans;&#125;&#125;; # 221. 最大正方形 ## 1. 题目描述 在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 示例: 输入: 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 输出: 4 ## 2. 解题思路 一开始是想和Leetoce 85. 最大矩阵这道题一起做的，所以在设计动态规划数组时候就留了一手。但随后发现最大矩阵那道题用这样的动态规划不太好弄。所以最后我又重新做了一遍这道最大正方形的题，力求让公式更加简洁。 用\\(dp[i][j]\\)表示以\\((i,j)\\)为右下角的正方形的边长。 状态转移方程如下： \\[ dp[i][j]= \\left \\{ \\begin{array}{lr} \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ matrix[i][j]==1\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ i=0||j=0\\\\ min\\{dp[i-1][j],dp[i-1][j-1],dp[i][j-1]\\}+1\\ \\ \\ \\ otherwise \\end{array} \\right . \\] 意思就是求分别以\\((i-1,j)\\)、\\((i-1,j-1)\\)、\\((i,j-1)\\)为右下角的正方形的交集的边长，如下图中阴影部分，就是紫色、蓝色、绿色三个正方形的交集。 然后就是空间优化，这里不详细说明了，请看代码。 3. 代码实现 3.1 没有空间优化 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public:int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;int dp[1050][1050];memset(dp, 0, sizeof(dp));int m = matrix.size();if (m &lt;= 0) return 0;int n = matrix[0].size();if (n &lt;= 0) return 0;int ans = 0;for (int i = 0; i &lt; m; i++) &#123;dp[i][0] = matrix[i][0] == '1';ans = max(ans, dp[i][0]);&#125;for (int j = 0; j &lt; n; j++) &#123;dp[0][j] = matrix[0][j] == '1';ans = max(ans, dp[0][j]);&#125;for (int i = 1; i &lt; m; i++) &#123;for (int j = 1; j &lt; n; j++) &#123;if (matrix[i][j] == '1') &#123;dp[i][j] = min(dp[i-1][j], min(dp[i-1][j-1], dp[i][j-1])) + 1;&#125;else &#123;dp[i][j] = 0;&#125;ans = max(ans, dp[i][j]);&#125;&#125;return ans*ans;&#125;&#125;; 3.2 有空间优化 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public:int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;int dp[1050];memset(dp, 0, sizeof(dp));int m = matrix.size();if (m &lt;= 0) return 0;int n = matrix[0].size();if (n &lt;= 0) return 0;int ans = 0;int cur, pre;for (int i = 0; i &lt; m; i++) &#123;for (int j = 0; j &lt; n; j++) &#123;if (matrix[i][j] == '0') &#123;dp[j] = 0;&#125;else &#123;if (i == 0) &#123;dp[j] = 1;&#125;else &#123;if (j == 0) &#123;pre = dp[j];dp[j] = 1;&#125;else &#123;cur = dp[j];dp[j] = min(dp[j], min(pre, dp[j-1])) + 1;pre = cur;&#125;&#125;&#125;ans = max(ans, dp[j]);&#125;&#125;return ans*ans;&#125;&#125;; 91. 解码方法 题目表述 一条包含字母 A-Z 的消息通过以下方式进行了编码： 'A' -&gt; 1 'B' -&gt; 2 ... 'Z' -&gt; 26 给定一个只包含数字的非空字符串，请计算解码方法的总数。 示例 1: 输入: &quot;12&quot; 输出: 2 解释: 它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。 示例 2: 输入: &quot;226&quot; 输出: 3 解释: 它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/decode-ways 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 还是利用动态规划。但与上一题最长回文子串不同的是，这道题的状态转移方程不一样，但都差不多。观察状态转移方程发现，可以将二维的数组压缩到一维。最后总结一下常见的状态转移方程的形式。 ps.弱弱地说一句，其实上一题也是可以优化，由\\(m\\times n\\)维变成\\(2\\times n\\)维的。 ### 下面开始吧 用\\(dp[i][j]\\)表示字符串\\(s[i:j]\\)编码的最大方案数。 ### 状态转移方程： \\[ dp[i][j]=max\\{dp[i][j-k-1]\\ |\\ 1\\leq s[j-k:j]\\leq 26,0\\leq k\\leq min\\{2,j-i+1\\} \\} \\] 我试着说明一下。 假设\\(dp[i][j-1]\\)已经知道了，也就是说字符串\\(s[i:j]\\)的编码方案数已知，现在考虑地第\\(j\\)位字符。需要做的是，选择从\\(j\\)位往前，选择\\(k\\)位字符，将它们跟第\\(j\\)位拼起来并看成一个整体，也就是将\\(s[i:j]\\)分成\\(s[i:j-k-1]\\)和\\(s[j-k:j]\\)两个部分，注意，这样分的前提是\\(s[j-k:j]\\)是可编码的，也就是对应着\\(1\\leq s[j-k:j]\\leq 26\\)这个条件。举个例子，\\(s=226\\)，现在考虑\\(6\\)这一位，如下图： 这是两种不同的方案，然后去这两中方案中的最大那一种就可以，也就是对应着公式中\\(max\\{dp[i][j-k-1]\\}\\)的部分。 因为从1到26，最大就是2位数，所以\\(k\\)最大是1，也就是最多往前选1个字符，又因为还需要保证\\(s[i:j-k-1]\\)不为空，所以需要\\(i\\leq j-k-1\\)，即\\(k\\leq j-i+1\\)，这就对应了公式中\\(0\\leq k\\leq min\\{2,j-i+1\\}\\)的部分。 然后说一下空间优化的问题。 从上面的状态转移方程可以看出，求\\(dp[i][j]\\)只需要第\\(i\\)行\\(j\\)左边的元素就行，用不着其他行的元素，所有可以二维降成一维。 降为一维后，还是进行跟原来类似的操作，只不过就是对这一维数组进行了多次操作，如下图。 优化之后的状态转移方程就变成了： \\[ dp[j]=max\\{dp[j-k-1]\\ |\\ 1\\leq s[j-k:j]\\leq 26,0\\leq k\\leq min\\{2,j-i+1\\} \\}\\\\ \\] 其中\\(i\\)表示当前是第几次操作。 ### 下面总结一下常见的状态转移形式，方程就不写了，记不住，就把图画一画吧。 紫色五角星表示要求的目标，蓝色表示求这个目标需要那些元素 第一类： 第二类： 第三类： ## 代码实现 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public:int numDecodings(string s) &#123;if (s.length() &lt;= 0) return 0;set&lt;string&gt; se &#123;\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\",\"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\",\"21\", \"22\", \"23\", \"24\", \"25\", \"26\"&#125;;int dp[3050] = &#123;0&#125;;for (int i = 0; i &lt; s.length(); i++) &#123;if (s[i] != '0') &#123;dp[i] = 1;&#125;&#125;int m = s.length();for (int t = 1; t &lt; m; t++) &#123;int i, j;i = m - t - 1;for (j = i+1; j &lt; m; j++) &#123;int cur = 0;for (int k = 0; k &lt;= min(1, j-i+1); k++) &#123;if (se.find(s.substr(j-k, k+1)) != se.end()) &#123;if (j - k - 1 &lt; i) &#123;cur += 1;&#125;elsecur += dp[j-k-1];&#125;&#125;dp[j] = cur;&#125;&#125;return dp[m-1];&#125;&#125;; # 接上一题 Leetcode 95. 不同的二叉搜索树 II ## 题目描述 给定一个整数 n，生成所有由 1 ... n 为节点所组成的二叉搜索树。 实例 输入: 3 输出: [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]] ## 解题思路 这道题用不着动态规划，也用不着卡特兰数列，只要明白了树的构建过程，然后构建树就行了，就像是根据前序和中序序列构建树那样。 稍微需要注意的就是这里，左右子树组合的方法： 12345678for (auto&amp; l: left) &#123;for (auto&amp; r: right) &#123;TreeNode *root = new TreeNode(k);root-&gt;left = l;root-&gt;right = r;ans.push_back(root);&#125;&#125; ## 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940/*** Definition for a binary tree node.* struct TreeNode &#123;* int val;* TreeNode *left;* TreeNode *right;* TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;* &#125;;*/class Solution &#123;public:vector&lt;TreeNode*&gt; build(int i, int j) &#123;vector&lt;TreeNode*&gt; ans;if (i &gt; j) &#123;ans.push_back(NULL);return ans;&#125;for (int k = i; k &lt;= j; k++) &#123;vector&lt;TreeNode*&gt; left = build(i, k-1);vector&lt;TreeNode*&gt; right = build(k+1, j);for (auto&amp; l: left) &#123;for (auto&amp; r: right) &#123;TreeNode *root = new TreeNode(k);root-&gt;left = l;root-&gt;right = r;ans.push_back(root);&#125;&#125;&#125;return ans;&#125;vector&lt;TreeNode*&gt; generateTrees(int n) &#123;if (n == 0) &#123;vector&lt;TreeNode*&gt; ans;return ans;&#125;return build(1, n);&#125;&#125;; # Leetcode 96. 不同的二叉搜索树 ## 题目描述 给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？ ## 解题思路 ### 看图说话 假设\\(n=3\\)，那么初始数组就是\\([1,2,3]\\)。 首先从中选择一个数字作为根结点，可选择的点有3个，分别是\\(1,2,3\\)。假设选择了\\(1\\)，然后左子树即为空，再根据剩下的\\([2,3]\\)用同样的方法构造右子树。过程如下图： ### 用动态规划解释 用\\(f[n]\\)表示从1到n，n个数能组成的二叉搜索树的数量。根据上面的二叉树生成过程可以得出： \\[ f[n]= \\left \\{ \\begin{array}{clr} 1&amp; n\\leq 1\\\\ \\sum\\limits_{k=0}^{n-1}{f[k]\\times f[n-k-1]} &amp; n&gt;1 \\end{array} \\right . \\] 举个例子： \\[ f[5]=f[0]\\times f[4]\\\\ =f[1]\\times f[3]\\\\ =f[2]\\times f[2]\\\\ =f[3]\\times f[1]\\\\ =f[4]\\times f[0] \\] 也没啥好解释的，找找规律就能写出公式了。 ### 继续动态规划 如果是二维的呢？ \\[ f(i,j)= \\left \\{ \\begin{array}{clr} 1&amp; i\\geq j \\\\ \\sum\\limits_{k=i}^{j-1}f(i,k)\\times f(k+1,j)&amp; i&lt;j \\end{array} \\right . \\] 相同颜色是相互对应的。有兴趣的童鞋可以自行搜索“卡特兰数列”。 代码实现 12345678910111213class Solution &#123;public:int numTrees(int n) &#123;int f[1050] = &#123;0&#125;;f[0] = f[1] = 1;for (int i = 2; i &lt;= n; i++) &#123;for (int k = 0; k &lt; i; k++) &#123;f[i] += (f[k] * f[i-k-1]);&#125;&#125;return f[n];&#125;&#125;; Leetcode 152. 乘积最大子序列 1.题目描述 给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。 示例 1: 输入: [2,3,-2,4] 输出: 6 解释: 子数组 [2,3] 有最大乘积 6。 ## 2.解题思路 个人感觉这道题非常地有意思，其实用不上动态规划，或者说不是那种正规的动态规划。这道题的关键在于“负负得正”。 准备两个数组 12int real_max[1050];int fake_max[1050]; read_max[i]表示以nums[i]结尾的子数组的真实最大乘积； fake_max[i]表示以nums[i]结尾的子数组的可能最大乘积； ## 3.代码实现 1234567891011121314151617181920212223242526272829class Solution &#123;public:int maxProduct(vector&lt;int&gt;&amp; nums) &#123;int *real_max = new int[nums.size()];int *fake_max = new int[nums.size()];real_max[0] = fake_max[0] = nums[0];for (int i = 1; i &lt; nums.size(); i++) &#123;int a = nums[i];int b = nums[i] * real_max[i-1];int c = nums[i] * fake_max[i-1];real_max[i] = max(a, max(b, c));int tmp = min(a, min(b, c));if (tmp &lt; 0) fake_max[i] = tmp;else fake_max[i] = real_max[i];&#125;int ans = nums[0];for (int i = 0; i &lt; nums.size(); i++) &#123;ans = max(ans, real_max[i]);&#125;delete[] real_max;delete[] fake_max;return ans;&#125;&#125;; # Leetcode 322. 零钱兑换 ## 题目描述 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例 1: 输入: coins = [1, 2, 5], amount = 11 输出: 3 解释: 11 = 5 + 5 + 1 示例 2: 输入: coins = [2], amount = 3 输出: -1 说明: 你可以认为每种硬币的数量是无限的。 ## 解题思路 这道题跟[279. 完全平方数]如出一辙。 一开始用的是dfs+剪枝，结果超时了。然后换成动态规划，通过了。 代码实现 dfs+剪枝 12345678910111213141516171819202122232425262728//dfs+剪枝 超时class Solution &#123;public:int ans;void dfs(vector&lt;int&gt;&amp; coins, int i, int cur, int k) &#123;if (i &lt; 0 || k &lt; 0) return;// cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; cur &lt;&lt; \" k \"&lt;&lt;k &lt;&lt; endl;if (cur &gt;= ans) return;if (k == 0) &#123;ans = min(ans, cur);return;&#125;cur++;for (int j = i; j &gt;= 0; j--) &#123;dfs(coins, j, cur, k-coins[j]);&#125;&#125;int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;sort(coins.begin(), coins.end());ans = 999999;dfs(coins, coins.size()-1, 0, amount);if (ans == 999999) return -1;elsereturn ans;&#125;&#125;; 动态规划 1234567891011121314151617181920class Solution &#123;public:int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;int *dp = new int[amount+1];dp[0] = 0;for (int i = 1; i &lt;= amount; i++) &#123;int tmp = 99999;for (int j = 0; j &lt; coins.size(); j++) &#123;if ((i-coins[j]) &gt;= 0 &amp;&amp; dp[i-coins[j]] != -1) &#123;tmp = min(tmp, dp[i-coins[j]]+1);&#125;&#125;if (tmp == 99999) dp[i] = -1;else dp[i] = tmp;&#125;int ans = dp[amount];delete[] dp;return ans;&#125;&#125;; Leetcode 300. 最长上升子序列 题目描述 给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例: 输入: [10,9,2,5,3,7,101,18] 输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(n2) 。 进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗? ## 解题思路 用\\(dp[i]\\)表示以\\(nums[i]\\)结尾的上升子序列的长度。则状态转移方程如下： \\[ dp[i]=max\\{1,1+d[j]\\} \\] 其中\\(0\\leq j&lt; i\\)。 这样的时间复杂度是\\(O(n)\\times O(n)=O(n^2)\\)。 要优化的话，应该是可以把\\(j\\)的线性遍历变成二分查找。但具体我还没想好怎么弄。 ## 代码实现 12345678910111213141516171819202122232425class Solution &#123;public:int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;int n = nums.size();if (n &lt;= 0) return 0;int *dp = new int[n+1];int ans = 0;for (int i = 0; i &lt; n; i++) &#123;dp[i] = 1;for (int j = i-1; j &gt;= 0; j--) &#123;if (nums[i] &gt; nums[j]) &#123;dp[i] = max(dp[i], dp[j]+1);&#125;&#125;ans = max(ans, dp[i]);&#125;delete[] dp;return ans;&#125;&#125;; # Leetcode 5216. 统计元音字母序列的数目 ## 题目描述 给你一个整数 n，请你帮忙统计一下我们可以按下述规则形成多少个长度为 n 的字符串： 字符串中的每个字符都应当是小写元音字母（'a', 'e', 'i', 'o', 'u'） 每个元音 'a' 后面都只能跟着 'e' 每个元音 'e' 后面只能跟着 'a' 或者是 'i' 每个元音 'i' 后面 不能 再跟着另一个 'i' 每个元音 'o' 后面只能跟着 'i' 或者是 'u' 每个元音 'u' 后面只能跟着 'a' 由于答案可能会很大，所以请你返回 模 10^9 + 7 之后的结果。 示例 1： 输入：n = 1 输出：5 解释：所有可能的字符串分别是：&quot;a&quot;, &quot;e&quot;, &quot;i&quot; , &quot;o&quot; 和 &quot;u&quot;。 示例 2： 输入：n = 2 输出：10 解释：所有可能的字符串分别是：&quot;ae&quot;, &quot;ea&quot;, &quot;ei&quot;, &quot;ia&quot;, &quot;ie&quot;, &quot;io&quot;, &quot;iu&quot;, &quot;oi&quot;, &quot;ou&quot; 和 &quot;ua&quot;。 示例 3： 输入：n = 5 输出：68 提示： 1 &lt;= n &lt;= 2 10^4* ## 解题思路 动态规划。用\\(dp[i][0]\\)表示长度为\\(i\\)且最后一个字符是\\(a\\)的字符串数量；\\(dp[i][1]\\)表示长度为\\(i\\)且最后一个字符是\\(e\\)的字符串数量；…… $$ \\[\\begin{array}{clr} dp[i][0]&amp;=dp[i-1][1]+dp[i-1][2]+dp[i-1][4]\\\\ dp[i][1]&amp;=d[i-1][0]+dp[i-1][2]\\\\ ...&amp;=... \\end{array}\\] $$ 代码实现 1234567891011121314151617class Solution &#123;public:int countVowelPermutation(int n) &#123;long long int dp[20005][5];dp[1][0] = dp[1][1] = dp[1][2] = dp[1][3] = dp[1][4] = 1;for (int i = 2; i &lt;= n; i++) &#123;dp[i][0] = dp[i-1][1] + dp[i-1][2] + dp[i-1][4];dp[i][1] = dp[i-1][0] + dp[i-1][2];dp[i][2] = dp[i-1][1] + dp[i-1][3];dp[i][3] = dp[i-1][2];dp[i][4] = dp[i-1][2] + dp[i-1][3];for (int k = 0; k &lt; 5; k++) dp[i][k] %= 1000000007;&#125;return (dp[n][0] + dp[n][1] + dp[n][2] + dp[n][3] + dp[n][4]) % 1000000007;&#125;&#125;; 84. 柱状图中最大的矩形 题目描述 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 示例: 输入: [2,1,5,6,2,3] 输出: 10 ## 解题思路 利用单调栈。单调栈是个非常有意思的工具，利用它可以完成许多看似复杂的事务。单调栈本身的工作流程可能很容易让人困惑，但其实它背后的思想是及其简单和巧妙的。看完这个推荐去看[85. 最大矩形]。 ### 从头开始分析 针对这个题，如下图，人会怎么思考呢？ 我会先看最高的那个，也就是以6为高，能组成的最大矩形，结果是6；然后在再看次高的那个，也就是以5为高，能组成的最大矩形是10；然后看3，以此类推，知道最后一个，以1为高，能组成的最大的矩形为6。 接下来 试着从前往后遍历，先忽略前面的2，从1开始。首先遍历的是1 然后加入5 然后加入6 然后，重点来了，加入2。先不着急加入，从后往前，以6为高的矩形如下： 以5为高的矩形如下： 然后是1，1比2小，先不处理。把5和6拿出去，然后把2加入，如下： 然后加入3 所有数组处理完毕。然后从后往前，以3为高的矩形： 以2为高的矩形： 以1为高的矩形： 最大的就是以5为高的那个。 从上面的这个例子就基本能看出单调栈的工作流程了。 代码实现 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public:int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;if (heights.size() &lt;= 0) return 0;stack&lt;pair&lt;int, int&gt;&gt; st;heights.push_back(0);st.push(&#123;0, heights[0]&#125;);int ans = 0;for (int i = 1; i &lt; heights.size(); i++) &#123;pair&lt;int, int&gt; p = st.top();if (heights[i] == p.second) &#123;continue;&#125;else if (heights[i] &gt; p.second) &#123;st.push(&#123;i, heights[i]&#125;);&#125;else &#123;while (!st.empty() &amp;&amp; st.top().second &gt;= heights[i]) &#123;p = st.top();st.pop();ans = max(ans, p.second * ((i - 1) - p.first + 1));&#125;st.push(&#123;p.first, heights[i]&#125;);&#125;&#125;return ans;&#125;&#125;; Leetcode 85. 最大矩形 题目描述 给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 示例: 输入: [ [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]] 输出: 6 ## 解题思路 利用上一题84. 柱状图中最大的矩形的思想和代码。把这个矩阵一行一行的累加起来，然后就可以用上上一题的代码了。注意，这个累加跟平常的累加有些许不同，注意看下面第四行。 第一行，也就是求\\([1,0,1,0,0]\\)的柱状图中的最大矩形。 第二行，累加上第一行，也就是求\\([2,0,2,1,1]\\)的最大矩形。 第三行，就是求\\([3,1,3,2,2]\\)的最大矩形。 第四行，就是求\\([4,0,0,3,0]\\)的最大矩形。 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123;public:int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;if (heights.size() &lt;= 0) return 0;stack&lt;pair&lt;int, int&gt;&gt; st;heights.push_back(0);st.push(&#123;0, heights[0]&#125;);int ans = 0;for (int i = 1; i &lt; heights.size(); i++) &#123;pair&lt;int, int&gt; p = st.top();if (heights[i] == p.second) &#123;continue;&#125;else if (heights[i] &gt; p.second) &#123;st.push(&#123;i, heights[i]&#125;);&#125;else &#123;while (!st.empty() &amp;&amp; st.top().second &gt;= heights[i]) &#123;p = st.top();st.pop();ans = max(ans, p.second * ((i - 1) - p.first + 1));&#125;st.push(&#123;p.first, heights[i]&#125;);&#125;&#125;return ans;&#125;int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;int m = matrix.size();if (m &lt;= 0) return 0;int n = matrix[0].size();if (n &lt;= 0) return 0;vector&lt;int&gt; heights;int ans = 0;for (int i = 0; i &lt; m; i++) &#123;for (int j = 0; j &lt; n; j++) &#123;if (i == 0) &#123;heights.push_back(matrix[i][j] == '1' ? 1 : 0);&#125;else &#123;heights[j] = matrix[i][j] == '1' ? heights[j]+1 : 0;&#125;&#125;ans = max(ans, largestRectangleArea(heights));&#125;return ans;&#125;&#125;; 304. 二维区域和检索 - 矩阵不可变 题目描述 给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2)。 示例: 给定 matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]] sumRegion(2, 1, 4, 3) -&gt; 8 sumRegion(1, 1, 2, 2) -&gt; 11 sumRegion(1, 2, 2, 4) -&gt; 12 说明: 你可以假设矩阵不可变。 会多次调用 sumRegion 方法。 你可以假设 row1 ≤ row2 且 col1 ≤ col2。 ## 解题思路 树状数组。关于树状数组的有关说明可以看[220. 存在重复元素 III]，这里用到的是多维树状数组。 ### 核心代码 123456789101112131415161718192021int lowbit(int x) &#123;return x &amp; -x;&#125;void add(int i, int j, int v) &#123;for (int k = i; k &lt; n; k += lowbit(k)) &#123;for (int q = j; q &lt; n; q += lowbit(q)) &#123;c[k][q] += v;&#125;&#125;&#125;int mySum(int i, int j) &#123;int s = 0;for (int k = i; k &gt; 0; k -= lowbit(k)) &#123;for (int q = j; q &gt; 0; q -= lowbit(q)) &#123;s += c[k][q];&#125;&#125;return s;&#125; ## 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class NumMatrix &#123;public:int c[1050][1050];int n;NumMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;memset(c, 0, sizeof(c));n = 1050;for (int i = 0; i &lt; matrix.size(); i++) &#123;for (int j = 0; j &lt; matrix[i].size(); j++) &#123;add(i+1, j+1, matrix[i][j]);&#125;&#125;&#125;int lowbit(int x) &#123;return x &amp; -x;&#125;void add(int i, int j, int v) &#123;for (int k = i; k &lt; n; k += lowbit(k)) &#123;for (int q = j; q &lt; n; q += lowbit(q)) &#123;c[k][q] += v;&#125;&#125;&#125;int mySum(int i, int j) &#123;int s = 0;for (int k = i; k &gt; 0; k -= lowbit(k)) &#123;for (int q = j; q &gt; 0; q -= lowbit(q)) &#123;s += c[k][q];&#125;&#125;return s;&#125;int sumRegion(int row1, int col1, int row2, int col2) &#123;return mySum(row2+1, col2+1) - mySum(row1, col2+1) - mySum(row2+1, col1) + mySum(row1, col1);&#125;&#125;;/*** Your NumMatrix object will be instantiated and called as such:* NumMatrix* obj = new NumMatrix(matrix);* int param_1 = obj-&gt;sumRegion(row1,col1,row2,col2);*/ # 220. 存在重复元素 III 题目描述 给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/contains-duplicate-iii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 ## 树状数组 树状数组的通俗解释 树状数组本身是一个数组，只不过把它画成树的形式，为了更好理解接下来的操作。下面来结合图片进行说明。 首先假设有一个原始数组\\(A\\)，\\(A=[1,2,3,4,5,6,7,8]\\)。图下图所示。 然后，再申请一个数组\\(C\\)，长度和\\(A\\)相同，初始状态\\(C\\)为空，即\\(C=[0,0,0,0,0,0,0,0]\\)。如下图所示。 这个\\(C\\)数组就是树状数组，可能现在还不不太清楚，怎么就树状数组了，别急，现在我们把\\(C\\)数组在形式上稍微改变一下，再和\\(A\\)数组对应起来，如下图所示。 现在在看，是不是\\(C\\)数组就像是一个树了，帅气智。然后需要了解的就是这个\\(C\\)数组究竟是用来干嘛的。还是看个例子。 $ C[1]=A[1]\\ C[2]=C[1]+A[2]=A[1]+A[2]\\ C[3]=A[3]=A[1]+A[2]+A[3]\\ C[4]=C[2]+C[3]+A[4]=A[1]+A[2]+A[3]+A[4]\\ C[5]=A[5]\\ C[6]=C[5]+A[6]=A[5]+A[6]\\ C[7]=A[7]\\ C[8]=C[4]+C[6]+C[7]+A[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8]\\ $ 这里直接给出计算\\(C[i]\\)的公式，\\(C[i]=sum\\{A[j]|i-2^k+1\\leq j \\leq i\\}\\ (k是i的二进制表示中末尾0的个数)\\)。其实从上图也能看出来。我们把数字都标上，就变成了下图。 然后，需要知道的就要 这个数组数组可以用来做什么。它能做的事有两个： \\(sum(i)\\)，计算\\(A[1]+A[2]+...+A[i]\\)； \\(add(i, x)\\), 让\\(A[i]\\)加上\\(x\\)，然后更新更个树状数组。 下面先说\\(sum(i)\\)。 \\(sum(i)=A[1]+A[2]+...+A[i]\\\\=A[1]+A[2]+A[i-2^k]+A[i-2^k+1]+...+A[i]\\\\=sum(i-2^k)+C[i]\\\\=sum(i-lowbit(i))+C[i]\\) 其中\\(lowbit(i)\\)是用来计算\\(2^k\\)的，其中\\(k\\)是\\(i\\)的二进制表示中末尾0的个数。 这里不解释了，直接上代码，用的就是\\(lowbit(i)\\)这个函数。 123int lowbit(int x) &#123;return x &amp; -x;&#125; 然后是\\(sum(i)\\)的代码实现： 1234567int sum(int x) &#123;int s = 0;for (int i = x; i &gt; 0; i -= lowbit(i)) &#123;s += c[i];&#125;return s;&#125; 说完\\(sum(i)\\)再说\\(add(i, x)\\)。\\(add(i, x)\\)其实就是\\(A[i]=A[i]+x\\)，其实就是看改变\\(A[i]\\)的时候会改变那些\\(C[j]\\)。跟\\(sum(i)\\)很像，只不过是反着来。下面是代码。 12345void add(int i, int x) &#123;for (int k = i; k &lt;= n; k += lowbit(k)) &#123;c[k] += x;&#125;&#125; 树状数组就先说这些，下面是树状数组的模版。 1234567891011121314151617181920static const int n = 20060;int c[n+1];int lowbit(int x) &#123;return x &amp; -x;&#125;void add(int x, int flag) &#123;for (int i = x; i &lt;= n; i += lowbit(i)) &#123;c[i] += flag;&#125;&#125;int sum(int x) &#123;int s = 0;for (int i = x; i &gt; 0; i -= lowbit(i)) &#123;s += c[i];&#125;return s;&#125; 解题思路 构造一个长度为\\(k\\)滑动窗口，然后利用树状数组查找这个滑动窗口中小于等于某个值的元素的个数。举个例子。 输入: nums = [1,0,1,1], k = 1, t = 2 输出: true 构造一个长度为1的滑动窗口，把0号加入到滑动窗口，此时滑动窗口为[1]，然后处理2号数字，也就是0。因为要满足nums [i] 和 nums [j] 的差的绝对值最大为 t，也即是\\(|nums[j]-0|\\leq t\\),也就是\\(-t+0\\leq nums[j]\\leq t+0\\)，也就是\\(-2\\leq nums[j]\\leq 2\\)，然后树状数组登场，查找当前滑动窗口中小于等于\\(t+0\\)的元素的个数，也就是小于等于2的元素的个数，[1]中小于等于2的元素有1个；然后查找当前滑动窗口中小于等于\\((-t+0)-1\\)的元素的个数（想想为啥要再减1），也就是小于等于-3的元素的个数，[1]中小于等于-3的元素有0个；所以[1]中大于等于2并且小于等于2的元素有1个。又因为这是在当前滑动窗口里找的，所以可定符合 i 和 j 之间的差的绝对值最大为 ķ。 如果在处理j号元素时，没有找到符合条件的元素，也就是让滑动窗口右移一位，也即是把\\(nums[j]\\)加入到滑动窗口，并把\\(nums[j-k]\\)移除滑动窗口。代码就是 12add(nums[j], 1); #表示滑动窗口中多了一个值为nums[j]的元素add(nums[j-k], -1); #表示滑动窗口中少了一个值为nums[j-k]的元素 前提是\\(j-k\\geq 0\\)。 以上就是答题思路，然而在具体实践中，常遇到的两个问题是 1. 求左右边界时有可能超int范围，要用long类型 2. 对数组进行离散化处理。再利用一个数组a，关键代码如下： 12345for (int i = 0; i &lt; nums.size(); i++) &#123;a[i] = nums[i];&#125;sort(a, a+nums.size());#排序an = unique(a, a + nums.size()) - a; #a的长度 在更新树状数组是，不再直接用\\(nums[i]\\)，然是用\\(nums[i]\\)在a数组中的下标。 ## 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123;public:static const int n = 20060;int c[n+1];int a[n+1];int an;int lowbit(int x) &#123;return x &amp; -x;&#125;void add(int x, int flag) &#123;for (int i = x; i &lt;= n; i += lowbit(i)) &#123;c[i] += flag;&#125;&#125;int sum(int x) &#123;int s = 0;for (int i = x; i &gt; 0; i -= lowbit(i)) &#123;s += c[i];&#125;return s;&#125;bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) &#123;memset(c, 0, sizeof(c));memset(a, 0, sizeof(a));for (int i = 0; i &lt; nums.size(); i++) &#123;a[i] = nums[i];&#125;sort(a, a+nums.size());an = unique(a, a + nums.size()) - a;for (int j = 0; j &lt; nums.size(); j++) &#123;long long int left = (long long int )-t + (long long int )nums[j]-1, right = (long long int )t + (long long int )nums[j];int idx_left = lower_bound(a, a+an, left) - a;int idx_right = lower_bound(a, a+an, right) - a;if (a[idx_left] == left) idx_left++;if (a[idx_right] == right) idx_right++;if (sum(idx_right) - sum(idx_left) &gt; 0) &#123;return true;&#125;int idx_j = lower_bound(a, a+an, nums[j]) - a + 1;add(idx_j, 1);int i = j - k;if (i &gt;= 0) &#123;int idx_i = lower_bound(a, a+an, nums[i]) - a + 1;add(idx_i, -1);&#125;&#125;return false;&#125;&#125;; Leetcode 5206. 删除字符串中的所有相邻重复项 II 题目描述 给你一个字符串 s，「k 倍重复项删除操作」将会从 s 中选择 k 个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。 你需要对 s 重复进行无限次这样的删除操作，直到无法继续为止。 在执行完所有删除操作后，返回最终得到的字符串。 本题答案保证唯一。 实例1 输入：s = &quot;abcd&quot;, k = 2 输出：&quot;abcd&quot; 解释：没有要删除的内容。 实例2 输入：s = &quot;deeedbbcccbdaa&quot;, k = 3 输出：&quot;aa&quot; 解释： 先删除 &quot;eee&quot; 和 &quot;ccc&quot;，得到 &quot;ddbbbdaa&quot; 再删除 &quot;bbb&quot;，得到 &quot;dddaa&quot; 最后删除 &quot;ddd&quot;，得到 &quot;aa&quot; 实例3 输入：s = &quot;pbbcggttciiippooaais&quot;, k = 2 输出：&quot;ps&quot; 提示 1 &lt;= s.length &lt;= 10^5 2 &lt;= k &lt;= 10^4 s 中只含有小写英文字母。 ## 解题思路 刚看到这道题的时候没有什么思路，想这会不会要用到哪种我还不知道的数据结构或者奇妙的字符串算法，然后没有往下做就去吃饭去了。在去吃饭的路上，突发灵感——栈。这道题不就跟后缀表达式那种题目有异曲同工之妙吗。 ## 代码实现 12345678910111213141516171819202122232425262728293031class Solution &#123;public:string removeDuplicates(string s, int k) &#123;deque&lt;pair&lt;char, int&gt;&gt; d;for (int i = 0; i &lt; s.length(); i++) &#123;if (d.empty()) &#123;d.push_back(&#123;s[i], 1&#125;);&#125;else &#123;if (d.back().first == s[i]) &#123;d.back().second++;&#125;else &#123;d.push_back(&#123;s[i], 1&#125;);&#125;&#125;if (d.back().second == k) &#123;d.pop_back();&#125;&#125;string ans = \"\";for (auto &amp; au : d) &#123;// cout &lt;&lt; au.first &lt;&lt; \" \" &lt;&lt; au.second &lt;&lt; endl;string tmp(au.second, au.first);ans += tmp;&#125;return ans;&#125;&#125;; # Leetcode 5214. 最长定差子序列 ## 题目描述 给你一个整数数组 arr 和一个整数 difference，请你找出 arr 中所有相邻元素之间的差等于给定 difference 的等差子序列，并返回其中最长的等差子序列的长度。 示例 1： 输入：arr = [1,2,3,4], difference = 1 输出：4 解释：最长的等差子序列是 [1,2,3,4]。 ## 解题思路 看到这个题目，第一个想到的就是刚刚做过的最长上升子序列。感觉就是稍微改一改就行了，然后提交发现，超时了。那么现在，就以这道最长定差子序列为例，说明一下我是如何进行优化的。 直接一点吧，本题的状态转移方程： \\[ dp[i]=\\{1,dp[j]+1\\} \\] 其中，\\(0\\leq j &lt; i\\)，并且还需要满足\\(arr[i]-arr[j]=difference\\)。 怎么获得适合的\\(j\\)呢？朴素的做法就是让\\(j\\)在\\([0,i-1]\\)这个区间，遍历就是了。这正是可以优化的地方。仔细想想我们真正需要的是什么，不就是单纯的一个满足\\(arr[i]-arr[j]=difference\\)的\\(j\\)吗，直接用一个map&lt;int, int&gt;来保存储存这些信息不就好了。这对应着代码里的m[arr[i]] = i;。 ## 代码实现 ### 超时 123456789101112131415161718class Solution &#123;public:int longestSubsequence(vector&lt;int&gt;&amp; arr, int difference) &#123;int dp[100005];dp[0] = 1;int ans = 1;for (int i = 1; i &lt; arr.size(); i++) &#123;dp[i] = 1;for (int j = i-1; j &gt;= 0; j--) &#123;if ((arr[i] - arr[j]) == difference) &#123;dp[i] = max(dp[i], dp[j]+1);&#125;&#125;ans = max(ans, dp[i]);&#125;return ans;&#125;&#125;; ### 通过 1234567891011121314151617181920212223class Solution &#123;public:int longestSubsequence(vector&lt;int&gt;&amp; arr, int difference) &#123;map&lt;int, int&gt; m;int dp[100005];dp[0] = 1;int ans = 1;m[arr[0]] = 0;for (int i = 1; i &lt; arr.size(); i++) &#123;dp[i] = 1;if (m.find(arr[i]-difference) != m.end()) &#123;int j = m[arr[i]-difference];dp[i] = dp[j]+1;&#125;m[arr[i]] = i;ans = max(ans, dp[i]);&#125;return ans;&#125;&#125;; # Leetcode 309. 最佳买卖股票时机含冷冻期 题目描述 给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例: 输入: [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] ## 解题思路 依然是动态规划。 用\\(dp[i]\\)表示到第\\(i\\)为止，能赚到的最多的钱。状态转移方程为： \\[ dp[i]= \\left \\{ \\begin{array}{lr} 0&amp; i\\leq 0\\\\ max\\{dp[i-1], prices[i]-prices[j]+dp[j-2]\\}&amp; otherwise \\end{array} \\right . \\] 说明：第\\(i\\)天有两种情况，一是不买不卖，二是卖。不能是买。 如果是情况一，则\\(dp[i]=dp[i-1]\\); 如果是情况二，则\\(dp[i]=max\\{prices[i]-prices[j]+dp[j-2]\\}\\)，其中\\(0\\leq j &lt; i\\)。因为如果第\\(j\\)天买入，则第\\(j-1\\)天是没法卖的，所以这里是\\(dp[j-2]\\)。 代码实现 1234567891011121314151617181920class Solution &#123;public:int maxProfit(vector&lt;int&gt;&amp; prices) &#123;if (prices.size() &lt;= 1) return 0;int dp[5050];dp[0] = 0;for (int i = 1; i &lt; prices.size(); i++) &#123;dp[i] = dp[i-1];for (int j = i-1; j &gt;= 0; j--) &#123;if (prices[i] - prices[j] &gt; 0) &#123;int tmp = 0;if (j-2 &gt;= 0) tmp = dp[j-2];dp[i] = max(dp[i],(prices[i]-prices[j]+tmp));&#125;&#125;&#125;return dp[prices.size()-1];&#125;&#125;;","categories":[],"tags":[]},{"title":"word2vec练习","slug":"word2vec练习","date":"2019-11-24T10:52:41.000Z","updated":"2019-11-25T11:29:27.544Z","comments":true,"path":"2019/11/24/word2vec练习/","link":"","permalink":"http://yoursite.com/2019/11/24/word2vec%E7%BB%83%E4%B9%A0/","excerpt":"","text":"原文 pytorch_word2vec_model.py 12345678910111213141516171819202122232425import numpy as npimport torchimport torch.nn as nnimport torch.nn.functional as Fclass SkipGram(nn.Module): def __init__(self, vocab_size, embd_size): super(SkipGram, self).__init__() self.embeddings = nn.Embedding(vocab_size, embd_size) def forward(self, focus, context): embed_focus = self.embeddings(focus) embed_ctx = self.embeddings(context) # score = torch.mm(embed_focus, torch.t(embed_ctx)) score = torch.mul(embed_focus, embed_ctx).sum(dim=1) log_probs = score #F.logsigmoid(score) return log_probs def loss(self, log_probs, target): loss_fn = nn.BCEWithLogitsLoss() # loss_fn = nn.NLLLoss() loss = loss_fn(log_probs, target) return loss pytorch_train.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import randomimport reimport torchimport torch.optim as optimfrom tqdm import tqdmfrom pytorch_word2vec_model import SkipGramepochs = 50negative_sampling = 4window = 2vocab_size = 1embd_size = 300device = \"cuda\" if torch.cuda.is_available() is True else \"cpu\"def batch_data(x, batch_size=128): in_w = [] out_w = [] target = [] for text in x: for i in range(window, len(text) - window): word_set = set() in_w.append(text[i]) in_w.append(text[i]) in_w.append(text[i]) in_w.append(text[i]) out_w.append(text[i - 2]) out_w.append(text[i - 1]) out_w.append(text[i + 1]) out_w.append(text[i + 2]) target.append(1) target.append(1) target.append(1) target.append(1) # negative sampling count = 0 while count &lt; negative_sampling: rand_id = random.randint(0, vocab_size-1) if not rand_id in word_set: in_w.append(text[i]) out_w.append(rand_id) target.append(0) count += 1 if len(out_w) &gt;= batch_size: yield [in_w, out_w, target] in_w = [] out_w = [] target = [] if out_w: yield [in_w, out_w, target]def train(train_text_id, model,opt): model.train() # 启用dropout和batch normalization ave_loss = 0 pbar = tqdm() cnt=0 for x_batch in batch_data(train_text_id): in_w, out_w, target = x_batch in_w_var = torch.tensor(in_w).to(device) out_w_var = torch.tensor(out_w).to(device) target_var = torch.tensor(target,dtype=torch.float).to(device) model.zero_grad() log_probs = model(in_w_var, out_w_var) loss = model.loss(log_probs, target_var) loss.backward() opt.step() ave_loss += loss.item() pbar.update(1) cnt += 1 pbar.set_description('&lt; loss: %.5f &gt;' % (ave_loss / cnt)) pbar.close()text_id = []vocab_dict = &#123;&#125;with open( 'corpus.txt', encoding='utf-8') as fp: for line in fp: lines = re.sub(\"[^A-Za-z0-9']+\", ' ', line).lower().split() line_id = [] for s in lines: if not s: continue if s not in vocab_dict: vocab_dict[s] = len(vocab_dict) id = vocab_dict[s] line_id.append(id) if id==11500: print(id,s) text_id.append(line_id)vocab_size = len(vocab_dict)print('vocab_size', vocab_size)model = SkipGram(vocab_size, embd_size).to(device)for epoch in range(epochs): print('epoch', epoch) opt = torch.optim.Adam(filter(lambda p: p.requires_grad, model.parameters()), lr=0.001, weight_decay=0) train(text_id, model,opt) logits的作用是把\\((0,1)\\)的数值，变到\\((-\\infty, \\infty)\\)。如果是分类，假设是0、1分类，1的概率是\\(p\\)，那变化公式是\\(\\frac{p}{1-p}\\)，一开始我以为是类似于\\(\\frac{某个概率}{1-这个概率}\\)这种形式，但是后来学到Logistic模型，发现好像不是这么回事，假设是N分类，则更像是\\(\\frac{p_k}{p_N}\\)，其中\\(k=1,2,...,N-1\\)。 代码里BCEWithLogitsLoss()是把\\((-\\infty, \\infty)\\)的数值，变到\\((0,1)\\)，通过sigmoid函数就可以实现。而其实，sigmoid函数就是从这里推导出来的。","categories":[],"tags":[{"name":"word2vec","slug":"word2vec","permalink":"http://yoursite.com/tags/word2vec/"}]},{"title":"EM算法","slug":"EM算法","date":"2019-11-22T14:25:00.000Z","updated":"2019-11-25T11:24:34.070Z","comments":true,"path":"2019/11/22/EM算法/","link":"","permalink":"http://yoursite.com/2019/11/22/EM%E7%AE%97%E6%B3%95/","excerpt":"","text":"EM参考资料 就像统计学习方法里讲的一样，从一个三硬币例子讲起。 假如有三枚硬币，投掷这三枚硬币正面朝上的概率分别为\\(\\pi\\)，\\(p\\)，\\(q\\)。 先投第一枚硬币，如果正面朝上，则接下来投第二枚硬币，然后记录该枚硬币的投掷情况，若正面朝上记为1，反面朝上记为0；如果第一枚硬币是反面朝上，则接下来投第三枚硬币，然后同理记录该枚硬币的投掷情况。 问题：求最后0、1数据的分布。 假设模型背后的参数是\\(\\theta\\)，则就是求\\(P(x;\\theta)\\)，其中\\(x\\in\\{0,1\\}\\)。 ## 极大似然估计 如果只是投一枚硬币，假设正面朝上被一个参数\\(q\\)指导着。连续投10次，观察到的数据是\\([0,1,0,1,0,1,0,1,0,1]\\)。然后设此10次投掷为一个事件，虽然该事件已经发生了，但假设我们带着现在观察到的数据，回到该事件尚未发生的时刻，然后找一个\\(q\\)，使得该事件的结果与我们已经观察到的结果一致。这是一个反推的过程，很好理解，但关键是要用数学表达出这个过程。 就这样表达：这个事件就是投10次，这10次投掷的结果分别是\\([0,1,0,1,0,1,0,1,0,1]\\)。则该事件的概率可以表达成： \\[ P(X=0;q) \\cdot P(X=1;q)\\cdot ...\\cdot P(X=1;q) \\] 需要我们做的工作是找到一个\\(q\\)，使得上述公式最大，就可以了。这样的话，可以把上述公式改写成\\(q\\)的函数，即： \\[ l(q)=P(X=0;q) \\cdot P(X=1;q)\\cdot ...\\cdot P(X=1;q) \\] 为了最大化上述公式，可以使用导数这个工具，但观察上述公式，连乘的形式不利于导数的运算，所以在效果不变的前提下，再次改写： \\[ l(q)=\\mathop{\\log}{[P(X=0;q) \\cdot P(X=1;q)\\cdot ...\\cdot P(X=1;q)]} \\] 也就是： \\[ l(q)=\\sum_{i=1}^{10}{\\mathop{\\log}{P(X=x_i;q)}} \\] 根据我们日常生活中的经验，一枚硬币，每一次投掷正面朝上的概率是一样的（上帝掷筛子吗），而这里的这个概率正好可以跟前面讲的\\(q\\)关联起来，所以，顺水推舟地，设 \\[ P(X=1)=q\\\\ P(X=0)=1-q \\] 然后： \\[ l(q)=\\sum_{i=1}^{10}{\\mathop{\\log}{P(X=x_i)}}=\\mathop{\\log}{q}\\cdot \\mathop{\\log}{(1-q)} \\cdot ... \\cdot \\mathop{\\log}{(1-q)} \\] 最大化这个式子，得出\\(q=0.5\\)。 一般化的形式： \\[ l(q)=\\sum_{i=1}^{N}{\\mathop{\\log}{[q^{x_i}\\cdot (1-q)^{1-x_i}]}} \\] 对\\(q\\)求导： \\[ \\frac{\\partial{l(q)}}{\\partial{q}}=\\sum_{i}^{N}{\\frac{x_i-q}{q(1-q)}} \\] 令其等于0，解得\\(q=\\frac{\\sum{x_i}}{N}\\)。 ## EM算法 回到EM算中当中，设\\(Z\\)为第一次投币的结果，这是隐变量，不可观测。则部分观测似然函数是： \\[ l(\\theta)=\\sum_{i=1}^{N}{\\mathop{\\log{P(x_i;\\theta)}}} \\] 这个式子写不出像上面\\(l(q)=\\sum_{i=1}^{N}{\\mathop{\\log}{[q^{x_i}\\cdot (1-q)^{1-x_i}]}}\\)那样的式子，因为有个\\(\\pi\\)在那里档着。 假设能观测到\\(Z\\)，则完全观测似然函数是： \\[ l(\\theta)=\\sum_{i=1}^{N}{\\mathop{\\log{\\sum_{z}{P(x_i,z;\\theta)}}}} \\] 按道理来说，到这就可以用极大似然估计那一套去求\\(\\theta\\)的解析解，我估计大前辈们也是这么去做的，但是做的过程中发现有难度，不好做。于是最终就设置了EM这一套，专门用来求解此等问题。 Jensen： \\[ E[f(x)]\\ge f(E[x]) \\] \\(\\mathop{\\log}\\)是凹函数，所以\\(f(E[x])\\ge E[f(x)]\\)。就是利用这个方法，把上面似然函数的\\(\\mathop{\\log}\\)移到了第二个\\(\\sum\\)后面。为了利用Jensen还得设计一下\\(\\mathop{\\log}\\)内部的这个函数，把它写成期望的形式。 假设\\(Q(z)\\)是与\\(z\\)有关（但不是针对\\(z\\)）的的一个概率密度： \\[ l(\\theta)=\\sum_{i=1}^{N}{\\mathop{\\log}{\\sum_{z}{Q(z){\\frac{P(x_i,z;\\theta)}{Q(z)}}}}} \\] 然后运行Jensen不等式： \\[ l(\\theta)\\ge \\sum_{i=1}^{N}{\\sum_{z}{Q(z)\\mathop{\\log}{\\frac{P(x_i,z;\\theta)}{Q(z)}}}} \\] 取等号时，随机变量是一个常量， \\[ \\frac{P(x_i,z;\\theta)}{Q(z)}=c \\] 所以 \\[ Q(z)=\\frac{P(x_i,z;\\theta)}{c} \\] 因为之前构造\\(Q(z)\\)是给它的设定是概率密度，所以有 \\[ \\sum_{z}{Q(z)}=\\sum_{z}{\\frac{P(x_i,z;\\theta)}{c}}=1 \\] 然后，看到这个上面这个形式，它跟softmax非常像，于是自然而然地 \\[ \\sum_{z}{Q(z)}=\\sum_{z}{\\frac{P(x_i,z;\\theta)}{\\sum_{z}{P(x_i,z;\\theta)}}}=1 \\] 所以 \\[ Q(z)=\\frac{P(x_i,z;\\theta)}{\\sum_{z}{P(x_i,z;\\theta)}}=\\frac{P(x_i,z; \\theta)}{P(x_i;\\theta)}=P(z|x_i;\\theta) \\] 至此，\\(Q(z)\\)就构造出来了。 EM算法： E：根据参数\\(\\theta\\)计算每个样本属于每个\\(z\\)的概率，这个概率就是\\(Q(z)\\) M：根据得到的\\(Q(z)\\)，求出含有\\(\\theta\\)的似然函数的下界并最大化它，得到新的参数\\(\\theta\\)。 重复，至收敛。“可以看到，从思想上来说，和最开始没什么两样，只不过直接最大化似然函数不好做，曲线救国而已。”","categories":[],"tags":[{"name":"EM算法","slug":"EM算法","permalink":"http://yoursite.com/tags/EM%E7%AE%97%E6%B3%95/"}]},{"title":"github搜索技巧","slug":"github搜索技巧","date":"2019-11-22T14:23:00.000Z","updated":"2019-11-25T11:24:25.485Z","comments":true,"path":"2019/11/22/github搜索技巧/","link":"","permalink":"http://yoursite.com/2019/11/22/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/","excerpt":"","text":"in:name xxx in:readme xxx in:description xxx stars:&gt;100 forks:&gt;100 language:python pushed:&gt;2019-09-01","categories":[],"tags":[{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]},{"title":"03统计学习方法","slug":"03统计学习方法","date":"2019-11-19T12:10:46.000Z","updated":"2019-11-25T11:24:07.422Z","comments":true,"path":"2019/11/19/03统计学习方法/","link":"","permalink":"http://yoursite.com/2019/11/19/03%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/","excerpt":"","text":"第一周 从模型的角度 监督学习 无监督学习 半监督学习 强化学习 内容： 概论 感知机 k近邻 朴素贝叶斯 决策树 罗辑回归和最大熵 支持向量机 提升方法 EM算法机器推广 隐马尔可夫模型 条件随机场 总结 梯度下降法 牛顿法和拟牛顿法 拉格朗日对偶性 不同模型的差别在于：模型的假设和损失函数的设计 学习要求： 首先理解模型、算法的适用场景 然后理解模型、算法的逻辑框架 依据自己能力掌握个别推导细节 监督学习的实现步骤 得到一个有限的训练集合 得到模型的假设空间，也就是所有的备选模型 确定模型选择的准则，即学习的策略 实现求解最优模型的算法 通过学习方法选择最优模型 利用学习的最优模型对新数据进行预测或分析 对一个训练集，从里面拿出一下x和y来，这个拿取是随机的，可以用x和y的联合概率分布来表示（原来还有这种理解）。 条件概率分布$P(Y|X)$，预测形式$arg\\mathop{min}\\limits_{y}P(y|x)$ 模型有两种： 决策模型： 1F=\\&#123;f|Y=f_\\theta(X),\\theta\\in R^n\\&#125; 条件概率分布： 1F=\\&#123;P|P_&#123;\\theta&#125;(Y|X),\\theta\\in R^n\\&#125; F表示假设空间。举个例子，随机变量x和y，他俩是线性关系，如果用决策模型来描述，就是$Y=a_0+a_1X,\\theta=(a_0,a_1)^T$，如果用条件概率分布来描述，就是$Y\\sim N(a_0+a_1X,\\sigma^2)$，这样就决定了给定一个x的情况下，y服从正态分布由$a_0,a_1$决定。 泛化误差 学到的模型是$\\hat{f}$，用这个模型对未知数据预测的误差即为泛化误差： 重点：泛化误差上界 对于二分类问题，当假设空间是有限个函数的集合$F=\\{f_1,f_2,\\dots ,f_d\\}$时，对任意一个函数$f\\in F$，至少以概率$1-\\delta $，以下不等式成立： 12R(f)\\leq \\hat&#123;R&#125; (f)+\\varepsilon(d,N,\\delta )\\\\\\varepsilon(d,N,\\delta )=\\sqrt&#123;\\frac&#123;1&#125;&#123;2N&#125;(\\log&#123;d&#125;+\\log&#123;\\frac&#123;1&#125;&#123;\\delta &#125;&#125;)&#125; ### 证明： 霍夫丁不等式（Hoeffding's inequality）是机器学习的基础理论，通过它可以推导出机器学习在理论上的可行性。（这玩意从没见过。。） 在这里插入图片描述 在这里插入图片描述 MLE：最大似然估计 在这里插入图片描述 贝叶斯估计 在这里插入图片描述 作业1 在这里插入图片描述 在这里插入图片描述 在这里插入图片描述 感知机模型 假设：数据是线性可分的 在这里插入图片描述 在这里插入图片描述 算法收敛性 在这里插入图片描述 在这里插入图片描述 作业2 在这里插入图片描述 在这里插入图片描述 当w和b初始值为0时，eta就没有用了，因为被约去了 在这里插入图片描述 在这里插入图片描述 在这里插入图片描述 ## k近邻 数据不一定是线性可分的。 度量距离：欧氏距离 决策准则：多数表决 模型 在这里插入图片描述 度量距离 在这里插入图片描述 无穷范数 与输入变量相差最大的分量比较小 ##### 1、2范数 不仅与输入变量相差最大的分量比较小，而且每个分量都要小 ### k值得选择 交叉验证方法 ### 分类决策规则 上图其实就是举手表决法 kd树 在这里插入图片描述 在这里插入图片描述 作业3 1. 模型的复杂度体现在搜索距离分类点最近的k个样本。 K值越小，越容易过拟合 2. 线性扫描是O(n)，但是扫描完后还得选出最大的k个，如果用排序的话就是O(nlogn)。kd树是O(logn) ### sklearn 123456789101112131415161718192021222324252627282930313233343536import numpy as npfrom sklearn.neighbors import KNeighborsClassifierx = np.array([[5, 4],[9, 6],[4, 7],[2, 3],[8, 1],[7, 2]])y = np.array([0, 0, 0, 1, 1, 1])class_label = &#123;0: '正例', 1: '负例'&#125;sample = np.array([[5, 3], [3, 3]])for k in range(1, 7): print('k=&#123;&#125;'.format(k)) classifier = KNeighborsClassifier(n_neighbors=k) classifier.fit(x, y) result = classifier.predict(sample) print(result) for i in range(sample.shape[0]): print('\\t样本:&#123;&#125;, 预测结果:&#123;&#125;'.format(sample[i], class_label[result[i]]))output:k=1 样本:[5 3], 预测结果:正例 样本:[3 3], 预测结果:负例k=2 样本:[5 3], 预测结果:正例 样本:[3 3], 预测结果:正例k=3 样本:[5 3], 预测结果:负例 样本:[3 3], 预测结果:正例k=4 样本:[5 3], 预测结果:负例 样本:[3 3], 预测结果:正例k=5 样本:[5 3], 预测结果:负例 样本:[3 3], 预测结果:负例k=6 样本:[5 3], 预测结果:正例 样本:[3 3], 预测结果:正例 ### 自编程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import numpy as npclass K(): def __init__(self, k, x, y): self.x = x self.y = y self.k = k def calssifier(self, sample): nums_sample = sample.shape[0] nums_x = self.x.shape[0] # 数据扩充维度，方便利用矩阵运算求距离 _sample = np.stack([sample] * nums_x, axis=1) _x = np.stack([self.x] * nums_sample, axis=0) distance = np.sqrt(np.sum((_sample - _x) ** 2, axis=2)) # 距离排序 distance = np.argsort(distance, axis=-1) # 选择最近的k个 index = distance[:, :self.k] index = np.reshape(index, (-1)) result = self.y[index] result = np.reshape(result, (-1, self.k)) final_result = [] for res in result: final_result.append(np.argmax(np.bincount(res))) final_result = np.array(final_result) return final_resultx = np.array([[5, 4],[9, 6],[4, 7],[2, 3],[8, 1],[7, 2]])y = np.array([0, 0, 0, 1, 1, 1])class_label = &#123;0: '正例', 1: '负例'&#125;sample = np.array([[5, 3], [3, 3]])for k in range(1, 7): print('k=&#123;&#125;'.format(k)) k_classifier = K(k=k, x=x, y=y) result = k_classifier.calssifier(sample=sample) for i in range(sample.shape[0]): print('\\t样本:&#123;&#125;, 预测结果:&#123;&#125;'.format(sample[i], class_label[result[i]]))output:k=1 样本:[5 3], 预测结果:正例 样本:[3 3], 预测结果:负例k=2 样本:[5 3], 预测结果:正例 样本:[3 3], 预测结果:正例k=3 样本:[5 3], 预测结果:负例 样本:[3 3], 预测结果:正例k=4 样本:[5 3], 预测结果:负例 样本:[3 3], 预测结果:正例k=5 样本:[5 3], 预测结果:负例 样本:[3 3], 预测结果:负例k=6 样本:[5 3], 预测结果:正例 样本:[3 3], 预测结果:正例 ## 作业解答 ### 为什么极大似然估计里的概率密度函数，而不是概率 其实这里是用f(xi)代替了P(|x-xi|&lt;e)，即xi邻域的概率 贝叶斯估计 在这里插入图片描述 concurrent多线程、多进程小例子 12345678910111213141516171819from concurrent import futuresimport threadingimport osdef func(i): print(os.getpid(), threading.current_thread(), i) return i**2# with futures.ProcessPoolExecutor(max_workers=5) as executor:with futures.ThreadPoolExecutor(max_workers=5) as executor: # 建立多进程(线程)任务 tasks = [executor.submit(func, i) for i in range(10)] # 驱动多进行运行 done_iter = futures.as_completed(tasks) # 提取运行结果 res = [future.result() for future in done_iter] print(res) 第二周 朴素贝叶斯法 基于贝叶斯定理和特征条件独立假设的分类方法。 决策函数、条件概率 注意： 在估计该方法的参数时，可以使用极大似然估计法和贝叶斯估计法。这也意味着，不要混淆朴素贝叶斯分类法和贝叶斯估计法。 在这里插入图片描述 在这里插入图片描述 在这里插入图片描述 在这里插入图片描述 极大似然估计，上图第二项，有0的可能，所以换成了贝叶斯估计 在这里插入图片描述 在这里插入图片描述 在这里插入图片描述 在这里插入图片描述 在这里插入图片描述 在这里插入图片描述 在这里插入图片描述 决策树 模型 问题：如何选择根节点、如何避免过拟合。 ## 特征选择 再次复习，熵是自信息的期望。当事件以1/e概率出现时，熵最大。 经验熵： 使用有工作作为根节点，分类后的的条件熵是：（条件是有工作） H(D)是经验熵，H(D|A)是给定条件A下D的条件熵。差是增益，也就是熵变小了多少。换句话说，增益是数据混乱减少的程度。 意思就是某个特征分的类别越多，混乱程度是越大的，像是某种程度上的正则化。 ## 决策树的生成 第四步是预剪枝。 ## 剪枝 后剪枝。决策树叶子节点越多，说明模型越复杂，泛化能力低。 ## CART算法 二分树。 提出来了一个度量混乱程度的方法——基尼指数 选择Gini最小的那个特征。 不用考虑Ha(D)了，也就是不用考虑信息增益比了。因为这里是二叉树。 ## 熵、信息增益、基尼指数 熵和基尼指数都是衡量混乱程度的，用于离散变量。 方差：基本是用于连续变量。 内部节点是否剪枝只与该节点为根节点的子树有关！ 第三周 对数线性模型 logistics 判别模型 最大熵 生成模型 ## logistic logit变换，把0到1区间变换到\\(-\\infty\\)到\\(\\infty\\)。就是这么直接。 注意：公式里的\\(\\pi(x)\\)取值是\\([0,1]\\)。含义是概率。 然后反解出\\(\\pi(x)\\)。 可以看出来了，上面的公式就是凑出来的，但是凑得很好，很紧凑。 最终的公式（模型）： 其实就是造成了一个公式，把\\([-\\infty,\\infty]\\)变换到\\([0,1]\\)，然后把0到1的这个数看做是概率（赋予它概率的意义）。 这个是求w的方法。 上面就是在w的条件下，y的分布。 通过最大化上面的式子，求w。方法是梯度下降。 推导（这个才明白这个分子分母的设置，估计这个设计，解出来好看。也有可能是第一个这么做的人，“误导”了后人）： ## 最大熵 为什么选熵最大的：因为在不知道数据真实分布的情况是，假设各类数据是平均分布（熵最大）是比较合理的。 看下面这个例子，一目了然。 增加条件： “一弯”表示从样本里得出（观察得到）。 对上面的式子求期望，就能得到。 下面公式的意思是：让其在总体中出现的概率等于在样本中出现的概率。 上面第二行式子的意思：约束条件。条件就是要让熵最大，但是得符合实际情况。 求解结果： 区别： 以前都是直接使用x的取值，而这个最大熵模型是用的x和y的特征函数，也即是\\(f(x,y)\\)。 ## 拉格朗日对偶性 对应的L函数： 下面说明：为什么等价 然后，对偶形式： 三个定理： 定理一：对偶问题提供了一个原始问题解得下界。 定理二：给出了强对偶性的充分条件。也就告诉了我们什么时候可以利用对偶求原问题的解。 凸优化问题：在凸集上寻找凸函数的的极小值。 凸集、凸函数。 slater条件： 可行域的交集也得是凸集，且有内点。 正例： 反例: kkt条件。 ## 改进的迭代尺度法 。。。懵了。放弃，进下一章 支持向量机 硬间隔最大化 函数距离、几何距离 使用函数距离的问题。 函数距离的意义：当固定下一个超平面，判断不同的点到该超平面的距离。 ## 软间隔 ## 非线性与核函数 ## 序列最小最优化算法 两个两个轮换着优化。 \\(a=b\\) \\[ b=a \\]","categories":[],"tags":[{"name":"统计学习方法","slug":"统计学习方法","permalink":"http://yoursite.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"}]},{"title":"git基本使用","slug":"git基本使用","date":"2019-11-19T10:14:06.000Z","updated":"2019-11-25T11:23:19.448Z","comments":true,"path":"2019/11/19/git基本使用/","link":"","permalink":"http://yoursite.com/2019/11/19/git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"","text":"理想中的作业流程 在本机上通过pycharm写代码，然后通过git这个工具把代理同步到web端。 然后在服务器上使用git pull下来，然后运行。 如果在服务器端运行的过程中出现了什么问题，再回到本机上修改代码，再push到web端。 然后再在服务器上pull下来，运行。 大体就是这么个想法。 基本使用 先通过网页，在github上新建一个仓库。 然后可以通过git clone https://xxx.git克隆这个仓库，也可以现在本地做一些工作，然后通过git remote add origin https://xxx.git来关联远程仓库。 然后就是些基本命令： git add .将当前工作目录中的所有文件添加到工作区 git commit -m &quot;.&quot; 提交到（我也不知道是哪） git push推到web端 git pulldown都服务器上 其他命令 git branch branch_name新建一个分支 git checkout branch_name切换分支","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-11-18T10:18:54.368Z","updated":"2019-11-18T10:18:54.368Z","comments":true,"path":"2019/11/18/hello-world/","link":"","permalink":"http://yoursite.com/2019/11/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}